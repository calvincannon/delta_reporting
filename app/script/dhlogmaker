#!/usr/bin/perl

# TODO remove all use statements before deployment.
#use strict;
#use warnings;
#use Data::Dumper;

my $cf_workdir = '/var/cfengine/delta_reporting/log';
my $classes = "$cf_workdir/classes";
my $promises = "$cf_workdir/promises";
my $final_log = "$cf_workdir/final";
my ( $line, $timestamp );
my ( $handle, $class, $promiser, $promisee, $promise_outcome, %final_log );
my ( %timestamp, %classes, %promises);
my $timestamp = '^BEGIN (\d{4}-\d{2}-\d{2}\S*)';

format FINAL =
@* ;; @* ;; @* ;; @* ;; @* ;; @*
$timestamp, $class, $handle, $promiser, $promise_outcome, $promisee
.

sub readfile {
   my $ts;
	my $file = shift;
	my ( @file, %remove_duplicates);

	open(FH, "<", $file) || die "Cannot open $file, $!";
	while (<FH>){
		chomp;
      if ( m/$timestamp/ ){
         $ts = $_;
         next;
      }
		$remove_duplicates{$_} = '';
	}
	close FH;

	@file = keys %remove_duplicates;
   unshift( @file, $ts);
	return @file
}

my @classes = readfile $classes;
my @promises = readfile $promises;

foreach $line( @classes ) {

	undef %classes;
	undef %promises;

   if ( $line =~ m/$timestamp/ ) {
      $timestamp{'classes'} = $1;
      next;
   }elsif ( $timestamp{'classes'} eq '' ){
      next;
   }

	$classes{'class'} = $line;

	if ( $classes{'class'} =~ m/(.+)_handle_(.+)_(((not)?kept)|repaired)$/ ){

		$classes{'promiser'} = $1;
		$classes{'handle'} = $2;
      $classes{'promise_outcome'} = $3;

		for my $i ( 0 .. $#promises ) {

			if ( $promises[$i] =~ m/$timestamp/ ) {
				$timestamp{'promises'} = $1;
				# remove this entry for more efficent run the next time.
				splice @promises, $i, 1;
				next;
			}elsif ( $timestamp{'promises'} eq '' ){
				# remove this entry for more efficent run the next time.
				splice @promises, $i, 1;
				next;
         }

			( $promises{'handle'}, $promises{'promiser'}, $promises{'promisee'} ) = split /\s*;;\s*/, $promises[$i];

			$promises{'canonized'} = $promises{'promiser'};
			$promises{'canonized'} =~ s/[\W\s]/_/g;

			if (
				$classes{'handle'} eq $promises{'handle'} &&
				$classes{'promiser'} eq $promises{'canonized'} &&
			   $timestamp{'classes'} eq $timestamp{'promises'}
				) {
				# remove this entry for more efficent run the next time.
					splice @promises, $i, 1;
					last;

			} else {
				undef %promises;
			}
		}
	}
	if ( $timestamp{'promises'} eq '' ){ 
		$final_log{$classes{'class'}}{'timestamp'} = $timestamp{'classes'};
	} else {
		$final_log{$classes{'class'}}{'timestamp'} = $timestamp{'promises'};
	}
	$final_log{$classes{'class'}}{'handle'} = $promises{'handle'};
	$final_log{$classes{'class'}}{'promiser'} = $promises{'promiser'};
	$final_log{$classes{'class'}}{'promise_outcome'} = $classes{'promise_outcome'};
	$final_log{$classes{'class'}}{'promisee'} = $promises{'promisee'};
}

open (FINAL, ">>", $final_log) || die "Cannot open $final_log, $!";

foreach $class ( keys %final_log ){
	$timestamp = $final_log{$class}{'timestamp'};
	$handle = $final_log{$class}{'handle'};
	$promiser = $final_log{$class}{'promiser'};
	$promise_outcome = $final_log{$class}{'promise_outcome'};
	$promisee = $final_log{$class}{'promisee'};
	write FINAL;
   undef $timestamp;
   undef $handle;
   undef $promiser;
   undef $promise_outcome;
   undef $promisee;
}
close FINAL;
