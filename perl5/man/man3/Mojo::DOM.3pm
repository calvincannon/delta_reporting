.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::DOM 3"
.TH Mojo::DOM 3 "2014-10-17" "perl v5.20.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::DOM \- Minimalistic HTML/XML DOM parser with CSS selectors
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::DOM;
\&
\&  # Parse
\&  my $dom = Mojo::DOM\->new(\*(Aq<div><p id="a">Test</p><p id="b">123</p></div>\*(Aq);
\&
\&  # Find
\&  say $dom\->at(\*(Aq#b\*(Aq)\->text;
\&  say $dom\->find(\*(Aqp\*(Aq)\->text;
\&  say $dom\->find(\*(Aq[id]\*(Aq)\->attr(\*(Aqid\*(Aq);
\&
\&  # Walk
\&  say $dom\->div\->p\->[0]\->text;
\&  say $dom\->div\->children(\*(Aqp\*(Aq)\->first\->{id};
\&
\&  # Iterate
\&  $dom\->find(\*(Aqp[id]\*(Aq)\->reverse\->each(sub { say $_\->{id} });
\&
\&  # Loop
\&  for my $e ($dom\->find(\*(Aqp[id]\*(Aq)\->each) {
\&    say $e\->{id}, \*(Aq:\*(Aq, $e\->text;
\&  }
\&
\&  # Modify
\&  $dom\->div\->p\->last\->append(\*(Aq<p id="c">456</p>\*(Aq);
\&  $dom\->find(\*(Aq:not(p)\*(Aq)\->strip;
\&
\&  # Render
\&  say "$dom";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::DOM is a minimalistic and relaxed \s-1HTML/XML DOM\s0 parser with \s-1CSS\s0
selector support. It will even try to interpret broken \s-1XML,\s0 so you should not
use it for validation.
.SH "CASE SENSITIVITY"
.IX Header "CASE SENSITIVITY"
Mojo::DOM defaults to \s-1HTML\s0 semantics, that means all tags and attributes
are lowercased and selectors need to be lowercase as well.
.PP
.Vb 3
\&  my $dom = Mojo::DOM\->new(\*(Aq<P ID="greeting">Hi!</P>\*(Aq);
\&  say $dom\->at(\*(Aqp\*(Aq)\->text;
\&  say $dom\->p\->{id};
.Ve
.PP
If \s-1XML\s0 processing instructions are found, the parser will automatically switch
into \s-1XML\s0 mode and everything becomes case sensitive.
.PP
.Vb 3
\&  my $dom = Mojo::DOM\->new(\*(Aq<?xml version="1.0"?><P ID="greeting">Hi!</P>\*(Aq);
\&  say $dom\->at(\*(AqP\*(Aq)\->text;
\&  say $dom\->P\->{ID};
.Ve
.PP
\&\s-1XML\s0 detection can also be disabled with the \*(L"xml\*(R" method.
.PP
.Vb 2
\&  # Force XML semantics
\&  $dom\->xml(1);
\&
\&  # Force HTML semantics
\&  $dom\->xml(0);
.Ve
.SH "METHODS"
.IX Header "METHODS"
Mojo::DOM implements the following methods.
.SS "all_contents"
.IX Subsection "all_contents"
.Vb 1
\&  my $collection = $dom\->all_contents;
.Ve
.PP
Return a Mojo::Collection object containing all nodes in \s-1DOM\s0 structure as
Mojo::DOM objects.
.PP
.Vb 3
\&  # "<p><b>123</b></p>"
\&  $dom\->parse(\*(Aq<p><!\-\- Test \-\-><b>123<!\-\- 456 \-\-></b></p>\*(Aq)
\&    \->all_contents\->grep(sub { $_\->node eq \*(Aqcomment\*(Aq })\->remove\->first;
.Ve
.SS "all_text"
.IX Subsection "all_text"
.Vb 2
\&  my $trimmed   = $dom\->all_text;
\&  my $untrimmed = $dom\->all_text(0);
.Ve
.PP
Extract all text content from \s-1DOM\s0 structure, smart whitespace trimming is
enabled by default.
.PP
.Vb 2
\&  # "foo bar baz"
\&  $dom\->parse("<div>foo\en<p>bar</p>baz\en</div>")\->div\->all_text;
\&
\&  # "foo\enbarbaz\en"
\&  $dom\->parse("<div>foo\en<p>bar</p>baz\en</div>")\->div\->all_text(0);
.Ve
.SS "ancestors"
.IX Subsection "ancestors"
.Vb 2
\&  my $collection = $dom\->ancestors;
\&  my $collection = $dom\->ancestors(\*(Aqdiv > p\*(Aq);
.Ve
.PP
Find all ancestors of this node matching the \s-1CSS\s0 selector and return a
Mojo::Collection object containing these elements as Mojo::DOM objects.
All selectors from \*(L"\s-1SELECTORS\*(R"\s0 in Mojo::DOM::CSS are supported.
.PP
.Vb 2
\&  # List types of ancestor elements
\&  say $dom\->ancestors\->type;
.Ve
.SS "append"
.IX Subsection "append"
.Vb 1
\&  $dom = $dom\->append(\*(Aq<p>I X Mojolicious!</p>\*(Aq);
.Ve
.PP
Append \s-1HTML/XML\s0 fragment to this node.
.PP
.Vb 3
\&  # "<div><h1>Test</h1><h2>123</h2></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)
\&    \->append(\*(Aq<h2>123</h2>\*(Aq)\->root;
\&
\&  # "<p>Test 123</p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->contents\->first\->append(\*(Aq 123\*(Aq)\->root;
.Ve
.SS "append_content"
.IX Subsection "append_content"
.Vb 1
\&  $dom = $dom\->append_content(\*(Aq<p>I X Mojolicious!</p>\*(Aq);
.Ve
.PP
Append \s-1HTML/XML\s0 fragment (for \f(CW\*(C`root\*(C'\fR and \f(CW\*(C`tag\*(C'\fR nodes) or raw content to this
node's content.
.PP
.Vb 3
\&  # "<div><h1>Test123</h1></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)
\&    \->append_content(\*(Aq123\*(Aq)\->root;
\&
\&  # "<!\-\- Test 123 \-\-><br>"
\&  $dom\->parse(\*(Aq<!\-\- Test \-\-><br>\*(Aq)
\&    \->contents\->first\->append_content(\*(Aq123 \*(Aq)\->root;
\&
\&  # "<p>Test<i>123</i></p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->append_content(\*(Aq<i>123</i>\*(Aq)\->root;
.Ve
.SS "at"
.IX Subsection "at"
.Vb 1
\&  my $result = $dom\->at(\*(Aqhtml title\*(Aq);
.Ve
.PP
Find first element in \s-1DOM\s0 structure matching the \s-1CSS\s0 selector and return it as
a Mojo::DOM object or return \f(CW\*(C`undef\*(C'\fR if none could be found. All selectors
from \*(L"\s-1SELECTORS\*(R"\s0 in Mojo::DOM::CSS are supported.
.PP
.Vb 2
\&  # Find first element with "svg" namespace definition
\&  my $namespace = $dom\->at(\*(Aq[xmlns\e:svg]\*(Aq)\->{\*(Aqxmlns:svg\*(Aq};
.Ve
.SS "attr"
.IX Subsection "attr"
.Vb 4
\&  my $hash = $dom\->attr;
\&  my $foo  = $dom\->attr(\*(Aqfoo\*(Aq);
\&  $dom     = $dom\->attr({foo => \*(Aqbar\*(Aq});
\&  $dom     = $dom\->attr(foo => \*(Aqbar\*(Aq);
.Ve
.PP
This element's attributes.
.PP
.Vb 2
\&  # List id attributes
\&  say $dom\->find(\*(Aq*\*(Aq)\->attr(\*(Aqid\*(Aq)\->compact;
.Ve
.SS "children"
.IX Subsection "children"
.Vb 2
\&  my $collection = $dom\->children;
\&  my $collection = $dom\->children(\*(Aqdiv > p\*(Aq);
.Ve
.PP
Find all children of this element matching the \s-1CSS\s0 selector and return a
Mojo::Collection object containing these elements as Mojo::DOM objects.
All selectors from \*(L"\s-1SELECTORS\*(R"\s0 in Mojo::DOM::CSS are supported.
.PP
.Vb 2
\&  # Show type of random child element
\&  say $dom\->children\->shuffle\->first\->type;
.Ve
.SS "content"
.IX Subsection "content"
.Vb 2
\&  my $str = $dom\->content;
\&  $dom    = $dom\->content(\*(Aq<p>I X Mojolicious!</p>\*(Aq);
.Ve
.PP
Return this node's content or replace it with \s-1HTML/XML\s0 fragment (for \f(CW\*(C`root\*(C'\fR
and \f(CW\*(C`tag\*(C'\fR nodes) or raw content.
.PP
.Vb 2
\&  # "<b>Test</b>"
\&  $dom\->parse(\*(Aq<div><b>Test</b></div>\*(Aq)\->div\->content;
\&
\&  # "<div><h1>123</h1></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->content(\*(Aq123\*(Aq)\->root;
\&
\&  # "<p><i>123</i></p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->content(\*(Aq<i>123</i>\*(Aq)\->root;
\&
\&  # "<div><h1></h1></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->content(\*(Aq\*(Aq)\->root;
\&
\&  # " Test "
\&  $dom\->parse(\*(Aq<!\-\- Test \-\-><br>\*(Aq)\->contents\->first\->content;
\&
\&  # "<div><!\-\- 123 \-\->456</div>"
\&  $dom\->parse(\*(Aq<div><!\-\- Test \-\->456</div>\*(Aq)\->at(\*(Aqdiv\*(Aq)
\&    \->contents\->first\->content(\*(Aq 123 \*(Aq)\->root;
.Ve
.SS "contents"
.IX Subsection "contents"
.Vb 1
\&  my $collection = $dom\->contents;
.Ve
.PP
Return a Mojo::Collection object containing the child nodes of this element
as Mojo::DOM objects.
.PP
.Vb 2
\&  # "<p><b>123</b></p>"
\&  $dom\->parse(\*(Aq<p>Test<b>123</b></p>\*(Aq)\->at(\*(Aqp\*(Aq)\->contents\->first\->remove;
\&
\&  # "<!\-\- Test \-\->"
\&  $dom\->parse(\*(Aq<!\-\- Test \-\-><b>123</b>\*(Aq)\->contents\->first;
.Ve
.SS "find"
.IX Subsection "find"
.Vb 1
\&  my $collection = $dom\->find(\*(Aqhtml title\*(Aq);
.Ve
.PP
Find all elements in \s-1DOM\s0 structure matching the \s-1CSS\s0 selector and return a
Mojo::Collection object containing these elements as Mojo::DOM objects.
All selectors from \*(L"\s-1SELECTORS\*(R"\s0 in Mojo::DOM::CSS are supported.
.PP
.Vb 2
\&  # Find a specific element and extract information
\&  my $id = $dom\->find(\*(Aqdiv\*(Aq)\->[23]{id};
\&
\&  # Extract information from multiple elements
\&  my @headers = $dom\->find(\*(Aqh1, h2, h3\*(Aq)\->text\->each;
\&
\&  # Count all the different tags
\&  my $hash = $dom\->find(\*(Aq*\*(Aq)\->type\->reduce(sub { $a\->{$b}++; $a }, {});
\&
\&  # Find elements with a class that contains dots
\&  my @divs = $dom\->find(\*(Aqdiv.foo\e.bar\*(Aq)\->each;
.Ve
.SS "match"
.IX Subsection "match"
.Vb 1
\&  my $result = $dom\->match(\*(Aqhtml title\*(Aq);
.Ve
.PP
Match the \s-1CSS\s0 selector against this element and return it as a Mojo::DOM
object or return \f(CW\*(C`undef\*(C'\fR if it didn't match. All selectors from
\&\*(L"\s-1SELECTORS\*(R"\s0 in Mojo::DOM::CSS are supported.
.SS "namespace"
.IX Subsection "namespace"
.Vb 1
\&  my $namespace = $dom\->namespace;
.Ve
.PP
Find this element's namespace.
.PP
.Vb 2
\&  # Find namespace for an element with namespace prefix
\&  my $namespace = $dom\->at(\*(Aqsvg > svg\e:circle\*(Aq)\->namespace;
\&
\&  # Find namespace for an element that may or may not have a namespace prefix
\&  my $namespace = $dom\->at(\*(Aqsvg > circle\*(Aq)\->namespace;
.Ve
.SS "new"
.IX Subsection "new"
.Vb 2
\&  my $dom = Mojo::DOM\->new;
\&  my $dom = Mojo::DOM\->new(\*(Aq<foo bar="baz">I X Mojolicious!</foo>\*(Aq);
.Ve
.PP
Construct a new scalar-based Mojo::DOM object and \*(L"parse\*(R" \s-1HTML/XML\s0
fragment if necessary.
.SS "next"
.IX Subsection "next"
.Vb 1
\&  my $sibling = $dom\->next;
.Ve
.PP
Return Mojo::DOM object for next sibling element or \f(CW\*(C`undef\*(C'\fR if there are
no more siblings.
.PP
.Vb 2
\&  # "<h2>123</h2>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1><h2>123</h2></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->next;
.Ve
.SS "next_sibling"
.IX Subsection "next_sibling"
.Vb 1
\&  my $sibling = $dom\->next_sibling;
.Ve
.PP
Return Mojo::DOM object for next sibling node or \f(CW\*(C`undef\*(C'\fR if there are no
more siblings.
.PP
.Vb 3
\&  # "456"
\&  $dom\->parse(\*(Aq<p><b>123</b><!\-\- Test \-\->456</p>\*(Aq)\->at(\*(Aqb\*(Aq)
\&    \->next_sibling\->next_sibling;
.Ve
.SS "node"
.IX Subsection "node"
.Vb 1
\&  my $type = $dom\->node;
.Ve
.PP
This node's type, usually \f(CW\*(C`cdata\*(C'\fR, \f(CW\*(C`comment\*(C'\fR, \f(CW\*(C`doctype\*(C'\fR, \f(CW\*(C`pi\*(C'\fR, \f(CW\*(C`raw\*(C'\fR,
\&\f(CW\*(C`root\*(C'\fR, \f(CW\*(C`tag\*(C'\fR or \f(CW\*(C`text\*(C'\fR.
.SS "parent"
.IX Subsection "parent"
.Vb 1
\&  my $parent = $dom\->parent;
.Ve
.PP
Return Mojo::DOM object for parent of this node or \f(CW\*(C`undef\*(C'\fR if this node
has no parent.
.SS "parse"
.IX Subsection "parse"
.Vb 1
\&  $dom = $dom\->parse(\*(Aq<foo bar="baz">I X Mojolicious!</foo>\*(Aq);
.Ve
.PP
Parse \s-1HTML/XML\s0 fragment with Mojo::DOM::HTML.
.PP
.Vb 2
\&  # Parse XML
\&  my $dom = Mojo::DOM\->new\->xml(1)\->parse($xml);
.Ve
.SS "prepend"
.IX Subsection "prepend"
.Vb 1
\&  $dom = $dom\->prepend(\*(Aq<p>I X Mojolicious!</p>\*(Aq);
.Ve
.PP
Prepend \s-1HTML/XML\s0 fragment to this node.
.PP
.Vb 3
\&  # "<div><h1>Test</h1><h2>123</h2></div>"
\&  $dom\->parse(\*(Aq<div><h2>123</h2></div>\*(Aq)\->at(\*(Aqh2\*(Aq)
\&    \->prepend(\*(Aq<h1>Test</h1>\*(Aq)\->root;
\&
\&  # "<p>Test 123</p>"
\&  $dom\->parse(\*(Aq<p>123</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->contents\->first\->prepend(\*(AqTest \*(Aq)\->root;
.Ve
.SS "prepend_content"
.IX Subsection "prepend_content"
.Vb 1
\&  $dom = $dom\->prepend_content(\*(Aq<p>I X Mojolicious!</p>\*(Aq);
.Ve
.PP
Prepend \s-1HTML/XML\s0 fragment (for \f(CW\*(C`root\*(C'\fR and \f(CW\*(C`tag\*(C'\fR nodes) or raw content to
this node's content.
.PP
.Vb 3
\&  # "<div><h2>Test123</h2></div>"
\&  $dom\->parse(\*(Aq<div><h2>123</h2></div>\*(Aq)\->at(\*(Aqh2\*(Aq)
\&    \->prepend_content(\*(AqTest\*(Aq)\->root;
\&
\&  # "<!\-\- Test 123 \-\-><br>"
\&  $dom\->parse(\*(Aq<!\-\- 123 \-\-><br>\*(Aq)
\&    \->contents\->first\->prepend_content(\*(Aq Test\*(Aq)\->root;
\&
\&  # "<p><i>123</i>Test</p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->prepend_content(\*(Aq<i>123</i>\*(Aq)\->root;
.Ve
.SS "previous"
.IX Subsection "previous"
.Vb 1
\&  my $sibling = $dom\->previous;
.Ve
.PP
Return Mojo::DOM object for previous sibling element or \f(CW\*(C`undef\*(C'\fR if there
are no more siblings.
.PP
.Vb 2
\&  # "<h1>Test</h1>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1><h2>123</h2></div>\*(Aq)\->at(\*(Aqh2\*(Aq)\->previous;
.Ve
.SS "previous_sibling"
.IX Subsection "previous_sibling"
.Vb 1
\&  my $sibling = $dom\->previous_sibling;
.Ve
.PP
Return Mojo::DOM object for previous sibling node or \f(CW\*(C`undef\*(C'\fR if there are
no more siblings.
.PP
.Vb 3
\&  # "123"
\&  $dom\->parse(\*(Aq<p>123<!\-\- Test \-\-><b>456</b></p>\*(Aq)\->at(\*(Aqb\*(Aq)
\&    \->previous_sibling\->previous_sibling;
.Ve
.SS "remove"
.IX Subsection "remove"
.Vb 1
\&  my $parent = $dom\->remove;
.Ve
.PP
Remove this node and return \*(L"parent\*(R".
.PP
.Vb 2
\&  # "<div></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->remove;
\&
\&  # "<p><b>456</b></p>"
\&  $dom\->parse(\*(Aq<p>123<b>456</b></p>\*(Aq)\->at(\*(Aqp\*(Aq)\->contents\->first\->remove\->root;
.Ve
.SS "replace"
.IX Subsection "replace"
.Vb 1
\&  my $parent = $dom\->replace(\*(Aq<div>I X Mojolicious!</div>\*(Aq);
.Ve
.PP
Replace this node with \s-1HTML/XML\s0 fragment and return \*(L"parent\*(R".
.PP
.Vb 2
\&  # "<div><h2>123</h2></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->replace(\*(Aq<h2>123</h2>\*(Aq);
\&
\&  # "<p><b>123</b></p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)
\&    \->contents\->[0]\->replace(\*(Aq<b>123</b>\*(Aq)\->root;
.Ve
.SS "root"
.IX Subsection "root"
.Vb 1
\&  my $root = $dom\->root;
.Ve
.PP
Return Mojo::DOM object for root node.
.SS "siblings"
.IX Subsection "siblings"
.Vb 2
\&  my $collection = $dom\->siblings;
\&  my $collection = $dom\->siblings(\*(Aqdiv > p\*(Aq);
.Ve
.PP
Find all sibling elements of this node matching the \s-1CSS\s0 selector and return a
Mojo::Collection object containing these elements as Mojo::DOM objects.
All selectors from \*(L"\s-1SELECTORS\*(R"\s0 in Mojo::DOM::CSS are supported.
.PP
.Vb 2
\&  # List types of sibling elements
\&  say $dom\->siblings\->type;
.Ve
.SS "strip"
.IX Subsection "strip"
.Vb 1
\&  my $parent = $dom\->strip;
.Ve
.PP
Remove this element while preserving its content and return \*(L"parent\*(R".
.PP
.Vb 2
\&  # "<div>Test</div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->strip;
.Ve
.SS "tap"
.IX Subsection "tap"
.Vb 1
\&  $dom = $dom\->tap(sub {...});
.Ve
.PP
Alias for \*(L"tap\*(R" in Mojo::Base.
.SS "text"
.IX Subsection "text"
.Vb 2
\&  my $trimmed   = $dom\->text;
\&  my $untrimmed = $dom\->text(0);
.Ve
.PP
Extract text content from this element only (not including child elements),
smart whitespace trimming is enabled by default.
.PP
.Vb 2
\&  # "foo baz"
\&  $dom\->parse("<div>foo\en<p>bar</p>baz\en</div>")\->div\->text;
\&
\&  # "foo\enbaz\en"
\&  $dom\->parse("<div>foo\en<p>bar</p>baz\en</div>")\->div\->text(0);
.Ve
.SS "to_string"
.IX Subsection "to_string"
.Vb 1
\&  my $str = $dom\->to_string;
.Ve
.PP
Render this node and its content to \s-1HTML/XML.\s0
.PP
.Vb 2
\&  # "<b>Test</b>"
\&  $dom\->parse(\*(Aq<div><b>Test</b></div>\*(Aq)\->div\->b\->to_string;
.Ve
.SS "tree"
.IX Subsection "tree"
.Vb 2
\&  my $tree = $dom\->tree;
\&  $dom     = $dom\->tree([\*(Aqroot\*(Aq]);
.Ve
.PP
Document Object Model. Note that this structure should only be used very
carefully since it is very dynamic.
.SS "type"
.IX Subsection "type"
.Vb 2
\&  my $type = $dom\->type;
\&  $dom     = $dom\->type(\*(Aqdiv\*(Aq);
.Ve
.PP
This element's type.
.PP
.Vb 2
\&  # List types of child elements
\&  say $dom\->children\->type;
.Ve
.SS "val"
.IX Subsection "val"
.Vb 1
\&  my $collection = $dom\->val;
.Ve
.PP
Extract values from \f(CW\*(C`button\*(C'\fR, \f(CW\*(C`input\*(C'\fR, \f(CW\*(C`option\*(C'\fR, \f(CW\*(C`select\*(C'\fR or \f(CW\*(C`textarea\*(C'\fR
element and return a Mojo::Collection object containing these values. In
the case of \f(CW\*(C`select\*(C'\fR, find all \f(CW\*(C`option\*(C'\fR elements it contains that have a
\&\f(CW\*(C`selected\*(C'\fR attribute and extract their values.
.PP
.Vb 2
\&  # "b"
\&  $dom\->parse(\*(Aq<input name="a" value="b">\*(Aq)\->at(\*(Aqinput\*(Aq)\->val;
\&
\&  # "c"
\&  $dom\->parse(\*(Aq<option value="c">Test</option>\*(Aq)\->at(\*(Aqoption\*(Aq)\->val;
\&
\&  # "d"
\&  $dom\->parse(\*(Aq<option>d</option>\*(Aq)\->at(\*(Aqoption\*(Aq)\->val;
.Ve
.SS "wrap"
.IX Subsection "wrap"
.Vb 1
\&  $dom = $dom\->wrap(\*(Aq<div></div>\*(Aq);
.Ve
.PP
Wrap \s-1HTML/XML\s0 fragment around this node, placing it as the last child of the
first innermost element.
.PP
.Vb 2
\&  # "<p>123<b>Test</b></p>"
\&  $dom\->parse(\*(Aq<b>Test</b>\*(Aq)\->at(\*(Aqb\*(Aq)\->wrap(\*(Aq<p>123</p>\*(Aq)\->root;
\&
\&  # "<div><p><b>Test</b></p>123</div>"
\&  $dom\->parse(\*(Aq<b>Test</b>\*(Aq)\->at(\*(Aqb\*(Aq)\->wrap(\*(Aq<div><p></p>123</div>\*(Aq)\->root;
\&
\&  # "<p><b>Test</b></p><p>123</p>"
\&  $dom\->parse(\*(Aq<b>Test</b>\*(Aq)\->at(\*(Aqb\*(Aq)\->wrap(\*(Aq<p></p><p>123</p>\*(Aq)\->root;
\&
\&  # "<p><b>Test</b></p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->contents\->first\->wrap(\*(Aq<b>\*(Aq)\->root;
.Ve
.SS "wrap_content"
.IX Subsection "wrap_content"
.Vb 1
\&  $dom = $dom\->wrap_content(\*(Aq<div></div>\*(Aq);
.Ve
.PP
Wrap \s-1HTML/XML\s0 fragment around this node's content, placing it as the last
children of the first innermost element.
.PP
.Vb 2
\&  # "<p><b>123Test</b></p>"
\&  $dom\->parse(\*(Aq<p>Test<p>\*(Aq)\->at(\*(Aqp\*(Aq)\->wrap_content(\*(Aq<b>123</b>\*(Aq)\->root;
\&
\&  # "<p><b>Test</b></p><p>123</p>"
\&  $dom\->parse(\*(Aq<b>Test</b>\*(Aq)\->wrap_content(\*(Aq<p></p><p>123</p>\*(Aq);
.Ve
.SS "xml"
.IX Subsection "xml"
.Vb 2
\&  my $bool = $dom\->xml;
\&  $dom     = $dom\->xml($bool);
.Ve
.PP
Disable \s-1HTML\s0 semantics in parser and activate case sensitivity, defaults to
auto detection based on processing instructions.
.SH "AUTOLOAD"
.IX Header "AUTOLOAD"
In addition to the \*(L"\s-1METHODS\*(R"\s0 above, many child elements are also
automatically available as object methods, which return a Mojo::DOM or
Mojo::Collection object, depending on number of children. For more power
and consistent results you can also use \*(L"children\*(R".
.PP
.Vb 2
\&  # "Test"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->p\->text;
\&
\&  # "123"
\&  $dom\->parse(\*(Aq<div>Test</div><div>123</div>\*(Aq)\->div\->[2]\->text;
\&
\&  # "Test"
\&  $dom\->parse(\*(Aq<div>Test</div>\*(Aq)\->div\->text;
.Ve
.SH "OPERATORS"
.IX Header "OPERATORS"
Mojo::DOM overloads the following operators.
.SS "array"
.IX Subsection "array"
.Vb 1
\&  my @nodes = @$dom;
.Ve
.PP
Alias for \*(L"contents\*(R".
.PP
.Vb 2
\&  # "<!\-\- Test \-\->"
\&  $dom\->parse(\*(Aq<!\-\- Test \-\-><b>123</b>\*(Aq)\->[0];
.Ve
.SS "bool"
.IX Subsection "bool"
.Vb 1
\&  my $bool = !!$dom;
.Ve
.PP
Always true.
.SS "hash"
.IX Subsection "hash"
.Vb 1
\&  my %attrs = %$dom;
.Ve
.PP
Alias for \*(L"attr\*(R".
.PP
.Vb 2
\&  # "test"
\&  $dom\->parse(\*(Aq<div id="test">Test</div>\*(Aq)\->at(\*(Aqdiv\*(Aq)\->{id};
.Ve
.SS "stringify"
.IX Subsection "stringify"
.Vb 1
\&  my $str = "$dom";
.Ve
.PP
Alias for \*(L"to_string\*(R".
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
