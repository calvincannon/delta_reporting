.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojolicious::Controller 3"
.TH Mojolicious::Controller 3 "2014-03-03" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojolicious::Controller \- Controller base class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  # Controller
\&  package MyApp::Foo;
\&  use Mojo::Base \*(AqMojolicious::Controller\*(Aq;
\&
\&  # Action
\&  sub bar {
\&    my $self = shift;
\&    my $name = $self\->param(\*(Aqname\*(Aq);
\&    $self\->res\->headers\->cache_control(\*(Aqmax\-age=1, no\-cache\*(Aq);
\&    $self\->render(json => {hello => $name});
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojolicious::Controller is the base class for your Mojolicious
controllers. It is also the default controller class unless you set
\&\*(L"controller_class\*(R" in Mojolicious.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojolicious::Controller inherits all attributes from Mojo::Base and
implements the following new ones.
.SS "app"
.IX Subsection "app"
.Vb 2
\&  my $app = $c\->app;
\&  $c      = $c\->app(Mojolicious\->new);
.Ve
.PP
A reference back to the application that dispatched to this controller,
defaults to a Mojolicious object.
.PP
.Vb 2
\&  # Use application logger
\&  $c\->app\->log\->debug(\*(AqHello Mojo!\*(Aq);
\&
\&  # Generate path
\&  my $path = $c\->app\->home\->rel_file(\*(Aqtemplates/foo/bar.html.ep\*(Aq);
.Ve
.SS "match"
.IX Subsection "match"
.Vb 2
\&  my $m = $c\->match;
\&  $c    = $c\->match(Mojolicious::Routes::Match\->new);
.Ve
.PP
Router results for the current request, defaults to a
Mojolicious::Routes::Match object.
.PP
.Vb 3
\&  # Introspect
\&  my $foo = $c\->match\->endpoint\->pattern\->defaults\->{foo};
\&  my $bar = $c\->match\->stack\->[\-1]{bar};
.Ve
.SS "tx"
.IX Subsection "tx"
.Vb 2
\&  my $tx = $c\->tx;
\&  $c     = $c\->tx(Mojo::Transaction::HTTP\->new);
.Ve
.PP
The transaction that is currently being processed, usually a
Mojo::Transaction::HTTP or Mojo::Transaction::WebSocket object. Note
that this reference is usually weakened, so the object needs to be referenced
elsewhere as well when you're performing non-blocking operations and the
underlying connection might get closed early.
.PP
.Vb 3
\&  # Check peer information
\&  my $address = $c\->tx\->remote_address;
\&  my $port    = $c\->tx\->remote_port;
\&
\&  # Perform non\-blocking operation without knowing the connection status
\&  my $tx = $c\->tx;
\&  Mojo::IOLoop\->timer(2 => sub {
\&    $c\->app\->log\->debug($tx\->is_finished ? \*(AqFinished.\*(Aq : \*(AqIn progress.\*(Aq);
\&  });
.Ve
.SH "METHODS"
.IX Header "METHODS"
Mojolicious::Controller inherits all methods from Mojo::Base and
implements the following new ones.
.SS "continue"
.IX Subsection "continue"
.Vb 1
\&  $c\->continue;
.Ve
.PP
Continue dispatch chain with \*(L"continue\*(R" in Mojolicious::Routes.
.SS "cookie"
.IX Subsection "cookie"
.Vb 4
\&  my $value  = $c\->cookie(\*(Aqfoo\*(Aq);
\&  my @values = $c\->cookie(\*(Aqfoo\*(Aq);
\&  $c         = $c\->cookie(foo => \*(Aqbar\*(Aq);
\&  $c         = $c\->cookie(foo => \*(Aqbar\*(Aq, {path => \*(Aq/\*(Aq});
.Ve
.PP
Access request cookie values and create new response cookies.
.PP
.Vb 2
\&  # Create response cookie with domain and expiration date
\&  $c\->cookie(user => \*(Aqsri\*(Aq, {domain => \*(Aqexample.com\*(Aq, expires => time + 60});
.Ve
.SS "finish"
.IX Subsection "finish"
.Vb 4
\&  $c = $c\->finish;
\&  $c = $c\->finish(1000);
\&  $c = $c\->finish(1003 => \*(AqCannot accept data!\*(Aq);
\&  $c = $c\->finish(\*(AqBye!\*(Aq);
.Ve
.PP
Close WebSocket connection or long poll stream gracefully.
.SS "flash"
.IX Subsection "flash"
.Vb 3
\&  my $foo = $c\->flash(\*(Aqfoo\*(Aq);
\&  $c      = $c\->flash({foo => \*(Aqbar\*(Aq});
\&  $c      = $c\->flash(foo => \*(Aqbar\*(Aq);
.Ve
.PP
Data storage persistent only for the next request, stored in the
\&\*(L"session\*(R".
.PP
.Vb 3
\&  # Show message after redirect
\&  $c\->flash(message => \*(AqUser created successfully!\*(Aq);
\&  $c\->redirect_to(\*(Aqshow_user\*(Aq, id => 23);
.Ve
.SS "on"
.IX Subsection "on"
.Vb 1
\&  my $cb = $c\->on(finish => sub {...});
.Ve
.PP
Subscribe to events of \*(L"tx\*(R", which is usually a Mojo::Transaction::HTTP
or Mojo::Transaction::WebSocket object. Note that this method will
automatically respond to WebSocket handshake requests with a \f(CW101\fR response
status.
.PP
.Vb 5
\&  # Do something after the transaction has been finished
\&  $c\->on(finish => sub {
\&    my $c = shift;
\&    $c\->app\->log\->debug(\*(AqWe are done!\*(Aq);
\&  });
\&
\&  # Receive WebSocket message
\&  $c\->on(message => sub {
\&    my ($c, $msg) = @_;
\&    $c\->app\->log\->debug("Message: $msg");
\&  });
\&
\&  # Receive JSON object via WebSocket message
\&  $c\->on(json => sub {
\&    my ($c, $hash) = @_;
\&    $c\->app\->log\->debug("Test: $hash\->{test}");
\&  });
\&
\&  # Receive WebSocket "Binary" message
\&  $c\->on(binary => sub {
\&    my ($c, $bytes) = @_;
\&    my $len = length $bytes;
\&    $c\->app\->log\->debug("Received $len bytes.");
\&  });
.Ve
.SS "param"
.IX Subsection "param"
.Vb 6
\&  my @names       = $c\->param;
\&  my $foo         = $c\->param(\*(Aqfoo\*(Aq);
\&  my @foo         = $c\->param(\*(Aqfoo\*(Aq);
\&  my ($foo, $bar) = $c\->param([\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq]);
\&  $c              = $c\->param(foo => \*(Aqba;r\*(Aq);
\&  $c              = $c\->param(foo => qw(ba;r ba;z));
.Ve
.PP
Access route placeholder values that are not reserved stash values, file
uploads and \s-1GET/POST\s0 parameters, in that order. Note that this method is
context sensitive in some cases and therefore needs to be used with care,
there can always be multiple values, which might have unexpected consequences.
Parts of the request body need to be loaded into memory to parse \s-1POST\s0
parameters, so you have to make sure it is not excessively large.
.PP
.Vb 2
\&  # List context is ambiguous and should be avoided
\&  my $hash = {foo => $self\->param(\*(Aqfoo\*(Aq)};
\&
\&  # Better enforce scalar context
\&  my $hash = {foo => scalar $self\->param(\*(Aqfoo\*(Aq)};
\&
\&  # The multi name form can also enforce scalar context
\&  my $hash = {foo => $self\->param([\*(Aqfoo\*(Aq])};
.Ve
.PP
For more control you can also access request information directly.
.PP
.Vb 2
\&  # Only GET parameters
\&  my $foo = $c\->req\->url\->query\->param(\*(Aqfoo\*(Aq);
\&
\&  # Only POST parameters
\&  my $foo = $c\->req\->body_params\->param(\*(Aqfoo\*(Aq);
\&
\&  # Only GET and POST parameters
\&  my $foo = $c\->req\->param(\*(Aqfoo\*(Aq);
\&
\&  # Only file uploads
\&  my $foo = $c\->req\->upload(\*(Aqfoo\*(Aq);
.Ve
.SS "redirect_to"
.IX Subsection "redirect_to"
.Vb 4
\&  $c = $c\->redirect_to(\*(Aqnamed\*(Aq, foo => \*(Aqbar\*(Aq);
\&  $c = $c\->redirect_to(\*(Aqnamed\*(Aq, {foo => \*(Aqbar\*(Aq});
\&  $c = $c\->redirect_to(\*(Aq/perldoc\*(Aq);
\&  $c = $c\->redirect_to(\*(Aqhttp://mojolicio.us/perldoc\*(Aq);
.Ve
.PP
Prepare a \f(CW302\fR redirect response, takes the same arguments as \*(L"url_for\*(R".
.PP
.Vb 3
\&  # Moved permanently
\&  $c\->res\->code(301);
\&  $c\->redirect_to(\*(Aqsome_route\*(Aq);
.Ve
.SS "render"
.IX Subsection "render"
.Vb 10
\&  my $bool   = $c\->render;
\&  my $bool   = $c\->render(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
\&  my $bool   = $c\->render(template => \*(Aqfoo/index\*(Aq);
\&  my $bool   = $c\->render(template => \*(Aqindex\*(Aq, format => \*(Aqhtml\*(Aq);
\&  my $bool   = $c\->render(data => $bytes);
\&  my $bool   = $c\->render(text => \*(AqHello!\*(Aq);
\&  my $bool   = $c\->render(json => {foo => \*(Aqbar\*(Aq});
\&  my $bool   = $c\->render(handler => \*(Aqsomething\*(Aq);
\&  my $bool   = $c\->render(\*(Aqfoo/index\*(Aq);
\&  my $output = $c\->render(\*(Aqfoo/index\*(Aq, partial => 1);
.Ve
.PP
Render content using \*(L"render\*(R" in Mojolicious::Renderer and emit hooks
\&\*(L"before_render\*(R" in Mojolicious as well as \*(L"after_render\*(R" in Mojolicious if the
result is not \f(CW\*(C`partial\*(C'\fR. If no template is provided a default one based on
controller and action or route name will be generated with
\&\*(L"template_for\*(R" in Mojolicious::Renderer, all additional values get merged into
the \*(L"stash\*(R".
.PP
.Vb 2
\&  # Render characters
\&  $c\->render(text => \*(AqI X Mojolicious!\*(Aq);
\&
\&  # Render binary data
\&  use Mojo::JSON \*(Aqencode_json\*(Aq;
\&  $c\->render(data => encode_json({test => \*(AqI X Mojolicious!\*(Aq}));
\&
\&  # Render JSON
\&  $c\->render(json => {test => \*(AqI X Mojolicious!\*(Aq});
\&
\&  # Render template "foo/bar.html.ep"
\&  $c\->render(template => \*(Aqfoo/bar\*(Aq, format => \*(Aqhtml\*(Aq, handler => \*(Aqep\*(Aq);
\&
\&  # Render template "foo/bar.*.*"
\&  $c\->render(template => \*(Aqfoo/bar\*(Aq);
\&
\&  # Render template "test.xml.*"
\&  $c\->render(\*(Aqtest\*(Aq, format => \*(Aqxml\*(Aq);
.Ve
.SS "render_exception"
.IX Subsection "render_exception"
.Vb 2
\&  $c = $c\->render_exception(\*(AqOops!\*(Aq);
\&  $c = $c\->render_exception(Mojo::Exception\->new(\*(AqOops!\*(Aq));
.Ve
.PP
Render the exception template \f(CW\*(C`exception.$mode.$format.*\*(C'\fR or
\&\f(CW\*(C`exception.$format.*\*(C'\fR and set the response status code to \f(CW500\fR. Also sets
the stash values \f(CW\*(C`exception\*(C'\fR to a Mojo::Exception object and \f(CW\*(C`snapshot\*(C'\fR
to a copy of the \*(L"stash\*(R" for use in the templates.
.SS "render_later"
.IX Subsection "render_later"
.Vb 1
\&  $c = $c\->render_later;
.Ve
.PP
Disable automatic rendering to delay response generation, only necessary if
automatic rendering would result in a response.
.PP
.Vb 5
\&  # Delayed rendering
\&  $c\->render_later;
\&  Mojo::IOLoop\->timer(2 => sub {
\&    $c\->render(text => \*(AqDelayed by 2 seconds!\*(Aq);
\&  });
.Ve
.SS "render_maybe"
.IX Subsection "render_maybe"
.Vb 3
\&  my $bool = $c\->render_maybe;
\&  my $bool = $c\->render_maybe(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
\&  my $bool = $c\->render_maybe(\*(Aqfoo/index\*(Aq, format => \*(Aqhtml\*(Aq);
.Ve
.PP
Try to render content but do not call \*(L"render_not_found\*(R" if no response
could be generated, takes the same arguments as \*(L"render\*(R".
.PP
.Vb 2
\&  # Render template "index_local" only if it exists
\&  $self\->render_maybe(\*(Aqindex_local\*(Aq) or $self\->render(\*(Aqindex\*(Aq);
.Ve
.SS "render_not_found"
.IX Subsection "render_not_found"
.Vb 1
\&  $c = $c\->render_not_found;
.Ve
.PP
Render the not found template \f(CW\*(C`not_found.$mode.$format.*\*(C'\fR or
\&\f(CW\*(C`not_found.$format.*\*(C'\fR and set the response status code to \f(CW404\fR. Also sets
the stash value \f(CW\*(C`snapshot\*(C'\fR to a copy of the \*(L"stash\*(R" for use in the
templates.
.SS "render_static"
.IX Subsection "render_static"
.Vb 2
\&  my $bool = $c\->render_static(\*(Aqimages/logo.png\*(Aq);
\&  my $bool = $c\->render_static(\*(Aq../lib/MyApp.pm\*(Aq);
.Ve
.PP
Render a static file using \*(L"serve\*(R" in Mojolicious::Static, usually from the
\&\f(CW\*(C`public\*(C'\fR directories or \f(CW\*(C`DATA\*(C'\fR sections of your application. Note that this
method does not protect from traversing to parent directories.
.SS "rendered"
.IX Subsection "rendered"
.Vb 2
\&  $c = $c\->rendered;
\&  $c = $c\->rendered(302);
.Ve
.PP
Finalize response and emit hook \*(L"after_dispatch\*(R" in Mojolicious, defaults to
using a \f(CW200\fR response code.
.PP
.Vb 4
\&  # Custom response
\&  $self\->res\->headers\->content_type(\*(Aqtext/plain\*(Aq);
\&  $self\->res\->body(\*(AqHello World!\*(Aq);
\&  $self\->rendered(200);
\&
\&  # Accept WebSocket handshake without subscribing to an event
\&  $self\->rendered(101);
.Ve
.SS "req"
.IX Subsection "req"
.Vb 1
\&  my $req = $c\->req;
.Ve
.PP
Get Mojo::Message::Request object from \*(L"req\*(R" in Mojo::Transaction.
.PP
.Vb 2
\&  # Longer version
\&  my $req = $c\->tx\->req;
\&
\&  # Extract request information
\&  my $url   = $c\->req\->url\->to_abs;
\&  my $info  = $c\->req\->url\->to_abs\->userinfo;
\&  my $host  = $c\->req\->url\->to_abs\->host;
\&  my $agent = $c\->req\->headers\->user_agent;
\&  my $bytes = $c\->req\->body;
\&  my $str   = $c\->req\->text;
\&  my $hash  = $c\->req\->params\->to_hash;
\&  my $value = $c\->req\->json;
\&  my $foo   = $c\->req\->json(\*(Aq/23/foo\*(Aq);
\&  my $dom   = $c\->req\->dom;
\&  my $bar   = $c\->req\->dom(\*(Aqdiv.bar\*(Aq)\->first\->text;
.Ve
.SS "res"
.IX Subsection "res"
.Vb 1
\&  my $res = $c\->res;
.Ve
.PP
Get Mojo::Message::Response object from \*(L"res\*(R" in Mojo::Transaction.
.PP
.Vb 2
\&  # Longer version
\&  my $res = $c\->tx\->res;
\&
\&  # Force file download by setting a custom response header
\&  $c\->res\->headers\->content_disposition(\*(Aqattachment; filename=foo.png;\*(Aq);
.Ve
.SS "respond_to"
.IX Subsection "respond_to"
.Vb 5
\&  $c = $c\->respond_to(
\&    json => {json => {message => \*(AqWelcome!\*(Aq}},
\&    html => {template => \*(Aqwelcome\*(Aq},
\&    any  => sub {...}
\&  );
.Ve
.PP
Automatically select best possible representation for resource from \f(CW\*(C`Accept\*(C'\fR
request header, \f(CW\*(C`format\*(C'\fR stash value or \f(CW\*(C`format\*(C'\fR \s-1GET/POST\s0 parameter,
defaults to rendering an empty \f(CW204\fR response. Since browsers often don't
really know what they actually want, unspecific \f(CW\*(C`Accept\*(C'\fR request headers with
more than one \s-1MIME\s0 type will be ignored, unless the \f(CW\*(C`X\-Requested\-With\*(C'\fR header
is set to the value \f(CW\*(C`XMLHttpRequest\*(C'\fR.
.PP
.Vb 5
\&  $c\->respond_to(
\&    json => sub { $c\->render(json => {just => \*(Aqworks\*(Aq}) },
\&    xml  => {text => \*(Aq<just>works</just>\*(Aq},
\&    any  => {data => \*(Aq\*(Aq, status => 204}
\&  );
.Ve
.PP
For more advanced negotiation logic you can also use the helper
\&\*(L"accepts\*(R" in Mojolicious::Plugin::DefaultHelper.
.SS "send"
.IX Subsection "send"
.Vb 6
\&  $c = $c\->send({binary => $bytes});
\&  $c = $c\->send({text   => $bytes});
\&  $c = $c\->send({json   => {test => [1, 2, 3]}});
\&  $c = $c\->send([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
\&  $c = $c\->send($chars);
\&  $c = $c\->send($chars => sub {...});
.Ve
.PP
Send message or frame non-blocking via WebSocket, the optional drain callback
will be invoked once all data has been written. Note that this method will
automatically respond to WebSocket handshake requests with a \f(CW101\fR response
status.
.PP
.Vb 2
\&  # Send "Text" message
\&  $c\->send(\*(AqI X Mojolicious!\*(Aq);
\&
\&  # Send JSON object as "Text" message
\&  $c\->send({json => {test => \*(AqI X Mojolicious!\*(Aq}});
\&
\&  # Send JSON object as "Binary" message
\&  use Mojo::JSON \*(Aqencode_json\*(Aq;
\&  $c\->send({binary => encode_json({test => \*(AqI X Mojolicious!\*(Aq})});
\&
\&  # Send "Ping" frame
\&  $c\->send([1, 0, 0, 0, 9, \*(AqHello World!\*(Aq]);
\&
\&  # Make sure previous message has been written before continuing
\&  $c\->send(\*(AqFirst message!\*(Aq => sub {
\&    my $c = shift;
\&    $c\->send(\*(AqSecond message!\*(Aq);
\&  });
.Ve
.PP
For mostly idle WebSockets you might also want to increase the inactivity
timeout, which usually defaults to \f(CW15\fR seconds.
.PP
.Vb 2
\&  # Increase inactivity timeout for connection to 300 seconds
\&  Mojo::IOLoop\->stream($c\->tx\->connection)\->timeout(300);
.Ve
.SS "session"
.IX Subsection "session"
.Vb 4
\&  my $session = $c\->session;
\&  my $foo     = $c\->session(\*(Aqfoo\*(Aq);
\&  $c          = $c\->session({foo => \*(Aqbar\*(Aq});
\&  $c          = $c\->session(foo => \*(Aqbar\*(Aq);
.Ve
.PP
Persistent data storage for the next few requests, all session data gets
serialized with Mojo::JSON and stored \f(CW\*(C`Base64\*(C'\fR encoded in \f(CW\*(C`HMAC\-SHA1\*(C'\fR
signed cookies. Note that cookies usually have a 4096 byte limit, depending on
browser.
.PP
.Vb 4
\&  # Manipulate session
\&  $c\->session\->{foo} = \*(Aqbar\*(Aq;
\&  my $foo = $c\->session\->{foo};
\&  delete $c\->session\->{foo};
\&
\&  # Expiration date in seconds from now (persists between requests)
\&  $c\->session(expiration => 604800);
\&
\&  # Expiration date as absolute epoch time (only valid for one request)
\&  $c\->session(expires => time + 604800);
\&
\&  # Delete whole session by setting an expiration date in the past
\&  $c\->session(expires => 1);
.Ve
.SS "signed_cookie"
.IX Subsection "signed_cookie"
.Vb 4
\&  my $value  = $c\->signed_cookie(\*(Aqfoo\*(Aq);
\&  my @values = $c\->signed_cookie(\*(Aqfoo\*(Aq);
\&  $c         = $c\->signed_cookie(foo => \*(Aqbar\*(Aq);
\&  $c         = $c\->signed_cookie(foo => \*(Aqbar\*(Aq, {path => \*(Aq/\*(Aq});
.Ve
.PP
Access signed request cookie values and create new signed response cookies.
Cookies failing \f(CW\*(C`HMAC\-SHA1\*(C'\fR signature verification will be automatically
discarded.
.SS "stash"
.IX Subsection "stash"
.Vb 4
\&  my $hash = $c\->stash;
\&  my $foo  = $c\->stash(\*(Aqfoo\*(Aq);
\&  $c       = $c\->stash({foo => \*(Aqbar\*(Aq});
\&  $c       = $c\->stash(foo => \*(Aqbar\*(Aq);
.Ve
.PP
Non-persistent data storage and exchange for the current request, application
wide default values can be set with \*(L"defaults\*(R" in Mojolicious. Some stash
values have a special meaning and are reserved, the full list is currently
\&\f(CW\*(C`action\*(C'\fR, \f(CW\*(C`app\*(C'\fR, \f(CW\*(C`cb\*(C'\fR, \f(CW\*(C`controller\*(C'\fR, \f(CW\*(C`data\*(C'\fR, \f(CW\*(C`extends\*(C'\fR, \f(CW\*(C`format\*(C'\fR,
\&\f(CW\*(C`handler\*(C'\fR, \f(CW\*(C`json\*(C'\fR, \f(CW\*(C`layout\*(C'\fR, \f(CW\*(C`namespace\*(C'\fR, \f(CW\*(C`partial\*(C'\fR, \f(CW\*(C`path\*(C'\fR, \f(CW\*(C`status\*(C'\fR,
\&\f(CW\*(C`template\*(C'\fR and \f(CW\*(C`text\*(C'\fR. Note that all stash values with a \f(CW\*(C`mojo.*\*(C'\fR prefix
are reserved for internal use.
.PP
.Vb 2
\&  # Remove value
\&  my $foo = delete $c\->stash\->{foo};
.Ve
.SS "url_for"
.IX Subsection "url_for"
.Vb 9
\&  my $url = $c\->url_for;
\&  my $url = $c\->url_for(name => \*(Aqsebastian\*(Aq);
\&  my $url = $c\->url_for({name => \*(Aqsebastian\*(Aq});
\&  my $url = $c\->url_for(\*(Aqtest\*(Aq, name => \*(Aqsebastian\*(Aq);
\&  my $url = $c\->url_for(\*(Aqtest\*(Aq, {name => \*(Aqsebastian\*(Aq});
\&  my $url = $c\->url_for(\*(Aq/perldoc\*(Aq);
\&  my $url = $c\->url_for(\*(Aq//mojolicio.us/perldoc\*(Aq);
\&  my $url = $c\->url_for(\*(Aqhttp://mojolicio.us/perldoc\*(Aq);
\&  my $url = $c\->url_for(\*(Aqmailto:sri@example.com\*(Aq);
.Ve
.PP
Generate a portable Mojo::URL object with base for a path, \s-1URL\s0 or route.
.PP
.Vb 2
\&  # "http://127.0.0.1:3000/perldoc" if application has been started with Morbo
\&  $c\->url_for(\*(Aq/perldoc\*(Aq)\->to_abs;
\&
\&  # "/perldoc?foo=bar" if application is deployed under "/"
\&  $c\->url_for(\*(Aq/perldoc\*(Aq)\->query(foo => \*(Aqbar\*(Aq);
\&
\&  # "/myapp/perldoc?foo=bar" if application is deployed under "/myapp"
\&  $c\->url_for(\*(Aq/perldoc\*(Aq)\->query(foo => \*(Aqbar\*(Aq);
.Ve
.PP
You can also use the helper \*(L"url_with\*(R" in Mojolicious::Plugin::DefaultHelpers
to inherit query parameters from the current request.
.PP
.Vb 2
\&  # "/list?q=mojo&page=2" if current request was for "/list?q=mojo&page=1"
\&  $c\->url_with\->query([page => 2]);
.Ve
.SS "validation"
.IX Subsection "validation"
.Vb 1
\&  my $validation = $c\->validation;
.Ve
.PP
Get Mojolicious::Validator::Validation object for current request to
validate \s-1GET/POST\s0 parameters. Parts of the request body need to be loaded into
memory to parse \s-1POST\s0 parameters, so you have to make sure it is not
excessively large.
.PP
.Vb 3
\&  my $validation = $c\->validation;
\&  $validation\->required(\*(Aqtitle\*(Aq)\->size(3, 50);
\&  my $title = $validation\->param(\*(Aqtitle\*(Aq);
.Ve
.SS "write"
.IX Subsection "write"
.Vb 4
\&  $c = $c\->write;
\&  $c = $c\->write($bytes);
\&  $c = $c\->write(sub {...});
\&  $c = $c\->write($bytes => sub {...});
.Ve
.PP
Write dynamic content non-blocking, the optional drain callback will be
invoked once all data has been written.
.PP
.Vb 6
\&  # Keep connection alive (with Content\-Length header)
\&  $c\->res\->headers\->content_length(6);
\&  $c\->write(\*(AqHel\*(Aq => sub {
\&    my $c = shift;
\&    $c\->write(\*(Aqlo!\*(Aq)
\&  });
\&
\&  # Close connection when finished (without Content\-Length header)
\&  $c\->write(\*(AqHel\*(Aq => sub {
\&    my $c = shift;
\&    $c\->write(\*(Aqlo!\*(Aq => sub {
\&      my $c = shift;
\&      $c\->finish;
\&    });
\&  });
.Ve
.PP
For Comet (long polling) you might also want to increase the inactivity
timeout, which usually defaults to \f(CW15\fR seconds.
.PP
.Vb 2
\&  # Increase inactivity timeout for connection to 300 seconds
\&  Mojo::IOLoop\->stream($c\->tx\->connection)\->timeout(300);
.Ve
.SS "write_chunk"
.IX Subsection "write_chunk"
.Vb 4
\&  $c = $c\->write_chunk;
\&  $c = $c\->write_chunk($bytes);
\&  $c = $c\->write_chunk(sub {...});
\&  $c = $c\->write_chunk($bytes => sub {...});
.Ve
.PP
Write dynamic content non-blocking with \f(CW\*(C`chunked\*(C'\fR transfer encoding, the
optional drain callback will be invoked once all data has been written.
.PP
.Vb 8
\&  # Make sure previous chunk has been written before continuing
\&  $c\->write_chunk(\*(AqHe\*(Aq => sub {
\&    my $c = shift;
\&    $c\->write_chunk(\*(Aqll\*(Aq => sub {
\&      my $c = shift;
\&      $c\->finish(\*(Aqo!\*(Aq);
\&    });
\&  });
.Ve
.PP
You can call \*(L"finish\*(R" at any time to end the stream.
.PP
.Vb 7
\&  2
\&  He
\&  2
\&  ll
\&  2
\&  o!
\&  0
.Ve
.SH "AUTOLOAD"
.IX Header "AUTOLOAD"
In addition to the \*(L"\s-1ATTRIBUTES\s0\*(R" and \*(L"\s-1METHODS\s0\*(R" above you can also call
helpers on Mojolicious::Controller objects. This includes all helpers from
Mojolicious::Plugin::DefaultHelpers and Mojolicious::Plugin::TagHelpers.
.PP
.Vb 2
\&  $c\->layout(\*(Aqgreen\*(Aq);
\&  $c\->title(\*(AqWelcome!\*(Aq);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
