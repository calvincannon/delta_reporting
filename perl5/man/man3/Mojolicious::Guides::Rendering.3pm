.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojolicious::Guides::Rendering 3"
.TH Mojolicious::Guides::Rendering 3 "2014-02-10" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojolicious::Guides::Rendering \- Rendering
.SH "OVERVIEW"
.IX Header "OVERVIEW"
This document explains content generation with the Mojolicious renderer.
.SH "CONCEPTS"
.IX Header "CONCEPTS"
Essentials every Mojolicious developer should know.
.SS "Renderer"
.IX Subsection "Renderer"
The renderer is a tiny black box turning stash data into actual responses
utilizing multiple template systems and data encoding modules.
.PP
.Vb 3
\&  {text => \*(AqHello.\*(Aq}                 \-> 200 OK, text/html, \*(AqHello.\*(Aq
\&  {json => {x => 3}}                 \-> 200 OK, application/json, \*(Aq{"x":3}\*(Aq
\&  {text => \*(AqOops.\*(Aq, status => \*(Aq410\*(Aq} \-> 410 Gone, text/html, \*(AqOops.\*(Aq
.Ve
.PP
Templates can be automatically detected if enough information is provided by
the developer or routes. Template names are expected to follow the
\&\f(CW\*(C`name.format.handler\*(C'\fR scheme, with \f(CW\*(C`name\*(C'\fR defaulting to \f(CW\*(C`controller/action\*(C'\fR
or the route name, \f(CW\*(C`format\*(C'\fR defaulting to \f(CW\*(C`html\*(C'\fR and \f(CW\*(C`handler\*(C'\fR to \f(CW\*(C`ep\*(C'\fR.
.PP
.Vb 3
\&  {controller => \*(Aqusers\*(Aq, action => \*(Aqlist\*(Aq} \-> \*(Aqusers/list.html.ep\*(Aq
\&  {name => \*(Aqfoo\*(Aq, format => \*(Aqtxt\*(Aq}          \-> \*(Aqfoo.txt.ep\*(Aq
\&  {name => \*(Aqfoo\*(Aq, handler => \*(Aqepl\*(Aq}         \-> \*(Aqfoo.html.epl\*(Aq
.Ve
.PP
All templates should be in the \f(CW\*(C`templates\*(C'\fR directories of the application or
the \f(CW\*(C`DATA\*(C'\fR section of the class \f(CW\*(C`main\*(C'\fR.
.PP
.Vb 1
\&  _\|_DATA_\|_
\&
\&  @@ time.html.ep
\&  % use Time::Piece;
\&  % my $now = localtime;
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title>Time</title></head>
\&    <body>The time is <%= $now\->hms %>.</body>
\&  </html>
\&
\&  @@ hello.txt.ep
\&  ...
.Ve
.PP
The renderer can be easily extended to support additional template systems
with plugins, but more about that later.
.SS "Embedded Perl"
.IX Subsection "Embedded Perl"
Mojolicious includes a minimalistic but very powerful template system out
of the box called Embedded Perl or \f(CW\*(C`ep\*(C'\fR for short. It allows the embedding of
Perl code right into actual content using a small set of special tags and line
start characters.
.PP
.Vb 10
\&  <% Perl code %>
\&  <%= Perl expression, replaced with XML escaped result %>
\&  <%== Perl expression, replaced with result %>
\&  <%# Comment, useful for debugging %>
\&  <%% Replaced with "<%", useful for generating templates %>
\&  % Perl code line, treated as "<% line =%>"
\&  %= Perl expression line, treated as "<%= line %>"
\&  %== Perl expression line, treated as "<%== line %>"
\&  %# Comment line, useful for debugging
\&  %% Replaced with "%", useful for generating templates
.Ve
.PP
Tags and lines work pretty much the same, but depending on context one will
usually look a bit better. Semicolons get automatically appended to all
expressions.
.PP
.Vb 8
\&  <% my $i = 10; %>
\&  <ul>
\&    <% for my $j (1 .. $i) { %>
\&      <li>
\&        <%= $j %>
\&      </li>
\&    <% } %>
\&  </ul>
\&
\&  % my $i = 10;
\&  <ul>
\&    % for my $j (1 .. $i) {
\&      <li>
\&        %= $j
\&      </li>
\&    % }
\&  </ul>
.Ve
.PP
Aside from differences in whitespace handling, both examples generate similar
Perl code, a naive translation could look like this.
.PP
.Vb 10
\&  my $output = \*(Aq\*(Aq;
\&  my $i = 10;
\&  $output .= \*(Aq<ul>\*(Aq;
\&  for my $j (1 .. $i) {
\&    $output .= \*(Aq<li>\*(Aq;
\&    $output .= xml_escape scalar $j;
\&    $output .= \*(Aq</li>\*(Aq;
\&  }
\&  $output .= \*(Aq</ul>\*(Aq;
\&  return $output;
.Ve
.PP
An additional equal sign can be used to disable escaping of the characters
\&\f(CW\*(C`<\*(C'\fR, \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`&\*(C'\fR, \f(CW\*(C`\*(Aq\*(C'\fR and \f(CW\*(C`"\*(C'\fR in results from Perl expressions,
which is the default to prevent \s-1XSS\s0 attacks against your application.
.PP
.Vb 2
\&  <%= \*(Aqlalala\*(Aq %>
\&  <%== \*(Aq<p>test</p>\*(Aq %>
.Ve
.PP
Only Mojo::ByteStream objects are excluded from automatic escaping.
.PP
.Vb 1
\&  <%= b(\*(Aq<p>test</p>\*(Aq) %>
.Ve
.PP
Newline characters can be escaped with a backslash.
.PP
.Vb 2
\&  This is <%= 1 + 1 %> a\e
\&  single line
.Ve
.PP
And a backslash in front of a newline character can be escaped with another
backslash.
.PP
.Vb 3
\&  This will <%= 1 + 1 %> result\e\e
\&  in multiple\e\e
\&  lines
.Ve
.PP
You can also add an additional equal sign to the end of a tag to have it
automatically remove all surrounding whitespace, this allows you to freely
indent your code without ruining the result.
.PP
.Vb 3
\&  <% for (1 .. 3) { %>
\&    <%= $foo =%>
\&  <% } %>
.Ve
.PP
Stash values that don't have invalid characters in their name get
automatically initialized as normal variables in the template, and the
controller object as \f(CW$self\fR.
.PP
.Vb 1
\&  $self\->stash(name => \*(Aqtester\*(Aq);
\&
\&  Hello <%= $name %> from <%= $self\->tx\->remote_address %>.
.Ve
.PP
There are also many helper functions available, but more about that later.
.PP
.Vb 1
\&  <%= dumper {foo => \*(Aqbar\*(Aq} %>
.Ve
.SH "BASICS"
.IX Header "BASICS"
Most commonly used features every Mojolicious developer should know about.
.SS "Automatic rendering"
.IX Subsection "Automatic rendering"
The renderer can be manually started by calling the method
\&\*(L"render\*(R" in Mojolicious::Controller, but that's usually not necessary,
because it will get automatically called if nothing has been rendered after
the router finished its work. This also means you can have routes pointing
only to templates without actual actions.
.PP
.Vb 1
\&  $self\->render;
.Ve
.PP
There is one big difference though, by calling it manually you can make sure
that templates use the current controller object, and not the default
controller specified with the attribute \*(L"controller_class\*(R" in Mojolicious.
.PP
.Vb 1
\&  $self\->render_later;
.Ve
.PP
You can also disable automatic rendering with the method
\&\*(L"render_later\*(R" in Mojolicious::Controller, which can be very useful to delay
rendering when a non-blocking operation has to be performed first.
.SS "Rendering templates"
.IX Subsection "Rendering templates"
The renderer will always try to detect the right template, but you can also
use the \f(CW\*(C`template\*(C'\fR stash value to render a specific one. Everything before
the last slash will be interpreted as the subdirectory path in which to find
the template.
.PP
.Vb 2
\&  # foo/bar/baz.*.*
\&  $self\->render(template => \*(Aqfoo/bar/baz\*(Aq);
.Ve
.PP
Choosing a specific \f(CW\*(C`format\*(C'\fR and \f(CW\*(C`handler\*(C'\fR is just as easy.
.PP
.Vb 2
\&  # foo/bar/baz.txt.epl
\&  $self\->render(template => \*(Aqfoo/bar/baz\*(Aq, format => \*(Aqtxt\*(Aq, handler => \*(Aqepl\*(Aq);
.Ve
.PP
Because rendering a specific template is the most common task it also has a
shortcut.
.PP
.Vb 1
\&  $self\->render(\*(Aqfoo/bar/baz\*(Aq);
.Ve
.PP
If you're not sure in advance if a template actually exists, you can also use
the method \*(L"render_maybe\*(R" in Mojolicious::Controller to try multiple
alternatives.
.PP
.Vb 1
\&  $self\->render_maybe(\*(Aqlocalized/baz\*(Aq) or $self\->render(\*(Aqfoo/bar/baz\*(Aq);
.Ve
.SS "Rendering inline templates"
.IX Subsection "Rendering inline templates"
Some renderers such as \f(CW\*(C`ep\*(C'\fR allow templates to be passed inline.
.PP
.Vb 1
\&  $self\->render(inline => \*(AqThe result is <%= 1 + 1 %>.\*(Aq);
.Ve
.PP
Since auto detection depends on a path you might have to supply a \f(CW\*(C`handler\*(C'\fR
too.
.PP
.Vb 1
\&  $self\->render(inline => "<%= shift\->param(\*(Aqfoo\*(Aq) %>", handler => \*(Aqepl\*(Aq);
.Ve
.SS "Rendering text"
.IX Subsection "Rendering text"
Characters can be rendered to bytes with the \f(CW\*(C`text\*(C'\fR stash value, the given
content will be automatically encoded to bytes.
.PP
.Vb 1
\&  $self\->render(text => \*(AqI X Mojolicious!\*(Aq);
.Ve
.SS "Rendering data"
.IX Subsection "Rendering data"
Bytes can be rendered with the \f(CW\*(C`data\*(C'\fR stash value, no encoding will be
performed.
.PP
.Vb 1
\&  $self\->render(data => $bytes);
.Ve
.SS "Rendering \s-1JSON\s0"
.IX Subsection "Rendering JSON"
The \f(CW\*(C`json\*(C'\fR stash value allows you to pass Perl data structures to the
renderer which get directly encoded to \s-1JSON\s0 with Mojo::JSON.
.PP
.Vb 1
\&  $self\->render(json => {foo => [1, \*(Aqtest\*(Aq, 3]});
.Ve
.SS "Partial rendering"
.IX Subsection "Partial rendering"
Sometimes you might want to use the rendered result directly instead of
generating a response, for example to send emails, this can be done using the
\&\f(CW\*(C`partial\*(C'\fR render argument (not the stash value).
.PP
.Vb 1
\&  my $html = $self\->render(\*(Aqmail\*(Aq, partial => 1);
.Ve
.PP
No encoding will be performed, making it easy to reuse the result in other
templates or to generate binary data.
.PP
.Vb 2
\&  my $pdf = $self\->render(\*(Aqinvoice\*(Aq, format => \*(Aqpdf\*(Aq, partial => 1);
\&  $self\->render(data => $pdf, format => \*(Aqpdf\*(Aq);
.Ve
.SS "Status code"
.IX Subsection "Status code"
Response status codes can be changed with the \f(CW\*(C`status\*(C'\fR stash value.
.PP
.Vb 1
\&  $self\->render(text => \*(AqOops.\*(Aq, status => 500);
.Ve
.SS "Content type"
.IX Subsection "Content type"
The \f(CW\*(C`Content\-Type\*(C'\fR header of the response is actually based on the \s-1MIME\s0 type
mapping of the \f(CW\*(C`format\*(C'\fR stash value.
.PP
.Vb 2
\&  # Content\-Type: text/plain
\&  $self\->render(text => \*(AqHello.\*(Aq, format => \*(Aqtxt\*(Aq);
\&
\&  # Content\-Type: image/png
\&  $self\->render(data => $bytes, format => \*(Aqpng\*(Aq);
.Ve
.PP
These mappings can be easily extended or changed with \*(L"types\*(R" in Mojolicious.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Add new MIME type
\&    $self\->types\->type(txt => \*(Aqtext/plain; charset=utf\-8\*(Aq);
\&  }
\&
\&  1;
.Ve
.SS "Stash data"
.IX Subsection "Stash data"
Any of the native Perl data types can be passed to templates through the
\&\*(L"stash\*(R" in Mojolicious::Controller.
.PP
.Vb 3
\&  $self\->stash(author     => \*(AqSebastian\*(Aq);
\&  $self\->stash(frameworks => [qw(Catalyst Mojolicious)]);
\&  $self\->stash(examples   => {tweetylicious => \*(Aqa microblogging app\*(Aq});
\&
\&  %= $author
\&  %= $frameworks\->[1]
\&  %= $examples\->{tweetylicious}
.Ve
.PP
Since everything is just Perl normal control structures just work.
.PP
.Vb 3
\&  % for my $framework (@$frameworks) {
\&    <%= $framework %> was written by <%= $author %>.
\&  % }
\&
\&  % while (my ($app, $description) = each %$examples) {
\&    <%= $app %> is a <%= $description %>.
\&  % }
.Ve
.SS "Content negotiation"
.IX Subsection "Content negotiation"
For resources with different representations and that require truly
\&\f(CW\*(C`RESTful\*(C'\fR content negotiation you can also use
\&\*(L"respond_to\*(R" in Mojolicious::Controller instead of
\&\*(L"render\*(R" in Mojolicious::Controller.
.PP
.Vb 10
\&  # /hello (Accept: application/json) \-> "json"
\&  # /hello (Accept: application/xml)  \-> "xml"
\&  # /hello.json                       \-> "json"
\&  # /hello.xml                        \-> "xml"
\&  # /hello?format=json                \-> "json"
\&  # /hello?format=xml                 \-> "xml"
\&  $self\->respond_to(
\&    json => {json => {hello => \*(Aqworld\*(Aq}},
\&    xml  => {text => \*(Aq<hello>world</hello>\*(Aq}
\&  );
.Ve
.PP
The best possible representation will be automatically selected from the
\&\f(CW\*(C`Accept\*(C'\fR request header, \f(CW\*(C`format\*(C'\fR stash value or \f(CW\*(C`format\*(C'\fR \s-1GET/POST\s0
parameter and stored in the \f(CW\*(C`format\*(C'\fR stash value. To change \s-1MIME\s0 type
mappings for the \f(CW\*(C`Accept\*(C'\fR request header or the \f(CW\*(C`Content\-Type\*(C'\fR response
header you can use \*(L"types\*(R" in Mojolicious.
.PP
.Vb 7
\&  $self\->respond_to(
\&    json => {json => {hello => \*(Aqworld\*(Aq}},
\&    html => sub {
\&      $self\->content_for(head => \*(Aq<meta name="author" content="sri">\*(Aq);
\&      $self\->render(template => \*(Aqhello\*(Aq, message => \*(Aqworld\*(Aq)
\&    }
\&  );
.Ve
.PP
Callbacks can be used for representations that are too complex to fit into a
single render call.
.PP
.Vb 10
\&  # /hello (Accept: application/json) \-> "json"
\&  # /hello (Accept: text/html)        \-> "html"
\&  # /hello (Accept: image/png)        \-> "any"
\&  # /hello.json                       \-> "json"
\&  # /hello.html                       \-> "html"
\&  # /hello.png                        \-> "any"
\&  # /hello?format=json                \-> "json"
\&  # /hello?format=html                \-> "html"
\&  # /hello?format=png                 \-> "any"
\&  $self\->respond_to(
\&    json => {json => {hello => \*(Aqworld\*(Aq}},
\&    html => {template => \*(Aqhello\*(Aq, message => \*(Aqworld\*(Aq},
\&    any  => {text => \*(Aq\*(Aq, status => 204}
\&  );
.Ve
.PP
And if no viable representation could be found, the \f(CW\*(C`any\*(C'\fR fallback will be
used or an empty \f(CW204\fR response rendered automatically.
.PP
.Vb 10
\&  # /hello                      \-> "html"
\&  # /hello (Accept: text/html)  \-> "html"
\&  # /hello (Accept: text/xml)   \-> "xml"
\&  # /hello (Accept: text/plain) \-> undef
\&  # /hello.html                 \-> "html"
\&  # /hello.xml                  \-> "xml"
\&  # /hello.txt                  \-> undef
\&  # /hello?format=html          \-> "html"
\&  # /hello?format=xml           \-> "xml"
\&  # /hello?format=txt           \-> undef
\&  if (my $format = $self\->accepts(\*(Aqhtml\*(Aq, \*(Aqxml\*(Aq)) {
\&    ...
\&  }
.Ve
.PP
For even more advanced negotiation logic you can also use the helper
\&\*(L"accepts\*(R" in Mojolicious::Plugin::DefaultHelpers.
.ie n .SS "Rendering ""exception"" and ""not_found"" pages"
.el .SS "Rendering \f(CWexception\fP and \f(CWnot_found\fP pages"
.IX Subsection "Rendering exception and not_found pages"
By now you've probably already encountered the built-in 404 (Not Found) and
500 (Server Error) pages, that get rendered automatically when you make a
mistake. Those are fallbacks for when your own exception handling fails, but
especially during development they can also be a great help, you can render
them manually with the methods \*(L"render_exception\*(R" in Mojolicious::Controller
and \*(L"render_not_found\*(R" in Mojolicious::Controller.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Scalar::Util \*(Aqlooks_like_number\*(Aq;
\&
\&  get \*(Aq/divide/:dividend/by/:divisor\*(Aq => sub {
\&    my $self = shift;
\&    my ($dividend, $divisor) = $self\->param([\*(Aqdividend\*(Aq, \*(Aqdivisor\*(Aq]);
\&
\&    # 404
\&    return $self\->render_not_found
\&      unless looks_like_number $dividend && looks_like_number $divisor;
\&
\&    # 500
\&    return $self\->render_exception(\*(AqDivision by zero!\*(Aq) if $divisor == 0;
\&
\&    # 200
\&    $self\->render(text => $dividend / $divisor);
\&  };
\&
\&  app\->start;
.Ve
.PP
You can also change the templates of those pages, since you most likely want
to show your users something more closely related to your application in
production. The renderer will always try to find \f(CW\*(C`exception.$mode.$format.*\*(C'\fR
or \f(CW\*(C`not_found.$mode.$format.*\*(C'\fR before falling back to the built-in default
templates.
.PP
.Vb 11
\&  @@ exception.production.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title>Server error</title></head>
\&    <body>
\&      <h1>Exception</h1>
\&      <p><%= $exception\->message %></p>
\&      <h1>Stash</h1>
\&      <pre><%= dumper $snapshot %></pre>
\&    </body>
\&  </html>
.Ve
.PP
The hook \*(L"before_render\*(R" in Mojolicious makes even more advanced
customizations possible by allowing you to intercept and modify the arguments
passed to the renderer.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  hook before_render => sub {
\&    my ($self, $args) = @_;
\&
\&    # Make sure we are rendering the exception template
\&    return unless my $template = $args\->{template};
\&    return unless $template eq \*(Aqexception\*(Aq;
\&
\&    # Switch to JSON rendering if content negotiation allows it
\&    $args\->{json} = {exception => $self\->stash(\*(Aqexception\*(Aq)}
\&      if $self\->accepts(\*(Aqjson\*(Aq);
\&  };
\&
\&  get \*(Aq/\*(Aq => sub { die "This sho...ALL GLORY TO THE HYPNOTOAD!\en" };
\&
\&  app\->start;
.Ve
.SS "Helpers"
.IX Subsection "Helpers"
Helpers are little functions you can use in templates and controller code.
.PP
.Vb 1
\&  %= dumper [1, 2, 3]
\&
\&  my $serialized = $self\->dumper([1, 2, 3]);
.Ve
.PP
The helper \*(L"dumper\*(R" in Mojolicious::Plugin::DefaultHelpers for example will
use Data::Dumper to serialize whatever data structure you pass it, this can
be very useful for debugging. We differentiate between \f(CW\*(C`default helpers\*(C'\fR
which are more general purpose like \f(CW\*(C`dumper\*(C'\fR and \f(CW\*(C`tag helpers\*(C'\fR, which are
template specific and mostly used to generate \f(CW\*(C`HTML\*(C'\fR tags.
.PP
.Vb 1
\&  %= javascript \*(Aq/script.js\*(Aq
\&
\&  %= javascript begin
\&    var a = \*(Aqb\*(Aq;
\&  % end
.Ve
.PP
A list of all built-in helpers can be found in
Mojolicious::Plugin::DefaultHelpers and Mojolicious::Plugin::TagHelpers.
.SS "Layouts"
.IX Subsection "Layouts"
Most of the time when using \f(CW\*(C`ep\*(C'\fR templates you will want to wrap your
generated content in a \s-1HTML\s0 skeleton, thanks to layouts that's absolutely
trivial.
.PP
.Vb 3
\&  @@ foo/bar.html.ep
\&  % layout \*(Aqmylayout\*(Aq;
\&  Hello World!
\&
\&  @@ layouts/mylayout.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title>MyApp</title></head>
\&    <body><%= content %></body>
\&  </html>
.Ve
.PP
You just select the right layout template with the helper
\&\*(L"layout\*(R" in Mojolicious::Plugin::DefaultHelpers and place the result of the
current template with the helper
\&\*(L"content\*(R" in Mojolicious::Plugin::DefaultHelpers. You can also pass along
normal stash values to the \f(CW\*(C`layout\*(C'\fR helper.
.PP
.Vb 3
\&  @@ foo/bar.html.ep
\&  % layout \*(Aqmylayout\*(Aq, title => \*(AqHi there\*(Aq;
\&  Hello World!
\&
\&  @@ layouts/mylayout.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title><%= $title %></title></head>
\&    <body><%= content %></body>
\&  </html>
.Ve
.PP
Instead of the \f(CW\*(C`layout\*(C'\fR helper you could also just use the \f(CW\*(C`layout\*(C'\fR stash
value, or call \*(L"render\*(R" in Mojolicious::Controller with the \f(CW\*(C`layout\*(C'\fR
argument.
.PP
.Vb 1
\&  $self\->render(template => \*(Aqmytemplate\*(Aq, layout => \*(Aqmylayout\*(Aq);
.Ve
.PP
To set a \f(CW\*(C`layout\*(C'\fR stash value application wide you can use
\&\*(L"defaults\*(R" in Mojolicious.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Default layout
\&    $self\->defaults(layout => \*(Aqmylayout\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
Layouts can also be used with \f(CW\*(C`partial\*(C'\fR templates, but the \f(CW\*(C`layout\*(C'\fR value
needs to be passed as a render argument (not a stash value).
.PP
.Vb 1
\&  my $html = $self\->render(\*(Aqreminder\*(Aq, layout => \*(Aqmail\*(Aq, partial => 1);
.Ve
.SS "Including partial templates"
.IX Subsection "Including partial templates"
Like most helpers \*(L"include\*(R" in Mojolicious::Plugin::DefaultHelpers is just a
shortcut to make your life a little easier.
.PP
.Vb 6
\&  @@ foo/bar.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    %= include \*(Aqheader\*(Aq
\&    <body>Bar</body>
\&  </html>
\&
\&  @@ header.html.ep
\&  <head><title>Howdy</title></head>
.Ve
.PP
Instead of \f(CW\*(C`include\*(C'\fR you could also just call
\&\*(L"render\*(R" in Mojolicious::Controller with the \f(CW\*(C`partial\*(C'\fR argument.
.PP
.Vb 6
\&  @@ foo/bar.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    %= $self\->render(\*(Aqheader\*(Aq, partial => 1)
\&    <body>Bar</body>
\&  </html>
\&
\&  @@ header.html.ep
\&  <head><title>Howdy</title></head>
.Ve
.PP
But there is one small difference between the two, if you pass stash values to
\&\f(CW\*(C`include\*(C'\fR, they will get localized automatically and are only available in
the partial template.
.PP
.Vb 6
\&  @@ foo/bar.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    %= include \*(Aqheader\*(Aq, title => \*(AqHello\*(Aq
\&    <body>Bar</body>
\&  </html>
\&
\&  @@ header.html.ep
\&  <head><title><%= $title %></title></head>
.Ve
.SS "Reusable template blocks"
.IX Subsection "Reusable template blocks"
It's never fun to repeat yourself, that's why you can build reusable template
blocks in \f(CW\*(C`ep\*(C'\fR that work very similar to normal Perl functions.
.PP
.Vb 7
\&  @@ welcome.html.ep
\&  <% my $block = begin %>
\&    <% my $name = shift; %>
\&    Hello <%= $name %>.
\&  <% end %>
\&  <%= $block\->(\*(AqSebastian\*(Aq) %>
\&  <%= $block\->(\*(AqSara\*(Aq) %>
.Ve
.PP
Blocks are always delimited by the \f(CW\*(C`begin\*(C'\fR and \f(CW\*(C`end\*(C'\fR keywords.
.PP
.Vb 8
\&  @@ welcome.html.ep
\&  % my $block = begin
\&    % my $name = shift;
\&    Hello <%= $name %>.
\&  % end
\&  % for (1 .. 10) {
\&    %== $block\->(\*(AqSebastian\*(Aq)
\&  % }
.Ve
.PP
A naive translation to Perl code could look like this.
.PP
.Vb 10
\&  @@ welcome.html.pl
\&  my $output = \*(Aq\*(Aq;
\&  my $block  = sub {
\&    my $name   = shift;
\&    my $output = \*(Aq\*(Aq;
\&    $output .= \*(AqHello \*(Aq;
\&    $output .= xml_escape scalar $name;
\&    $output .= \*(Aq.\*(Aq;
\&    return Mojo::ByteStream\->new($output);
\&  }
\&  for (1 .. 10) {
\&    $output .= scalar $block\->(\*(AqSebastian\*(Aq);
\&  }
\&  return $output;
.Ve
.SS "Content blocks"
.IX Subsection "Content blocks"
Blocks and the helper \*(L"content_for\*(R" in Mojolicious::Plugin::DefaultHelpers
can also be used to pass whole sections of the template to the layout.
.PP
.Vb 9
\&  @@ foo/bar.html.ep
\&  % layout \*(Aqmylayout\*(Aq;
\&  % content_for header => begin
\&    <meta http\-equiv="Content\-Type" content="text/html">
\&  % end
\&  <div>Hello World!</div>
\&  % content_for header => begin
\&    <meta http\-equiv="Pragma" content="no\-cache">
\&  % end
\&
\&  @@ layouts/mylayout.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head><%= content_for \*(Aqheader\*(Aq %></head>
\&    <body><%= content %></body>
\&  </html>
.Ve
.SS "Template inheritance"
.IX Subsection "Template inheritance"
Inheritance takes the layout concept above one step further, the helpers
\&\*(L"content\*(R" in Mojolicious::Plugin::DefaultHelpers and
\&\*(L"extends\*(R" in Mojolicious::Plugin::DefaultHelpers allow you to build a skeleton
template with named blocks that child templates can override.
.PP
.Vb 10
\&  @@ first.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title>Hello</title></head>
\&    <body>
\&      %= content header => begin
\&        Default header
\&      % end
\&      <div>Hello World!</div>
\&      %= content footer => begin
\&        Default footer
\&      % end
\&    </body>
\&  </html>
\&
\&  @@ second.html.ep
\&  % extends \*(Aqfirst\*(Aq;
\&  % content header => begin
\&    New header
\&  % end
.Ve
.PP
This chain could go on and on to allow a very high level of template reuse.
.SS "Form validation"
.IX Subsection "Form validation"
You can use \*(L"validation\*(R" in Mojolicious::Controller to validate \s-1GET/POST\s0
parameters submitted to your application. All unknown fields will be ignored
by default, so you have to decide which should be required or optional before
you can perform checks on their values. Every check is performed right away,
so you can use the results immediately to build more advanced validation logic
with methods like \*(L"is_valid\*(R" in Mojolicious::Validator::Validation.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  get \*(Aq/\*(Aq => sub {
\&    my $self = shift;
\&
\&    # Check if parameters have been submitted
\&    my $validation = $self\->validation;
\&    return $self\->render unless $validation\->has_data;
\&
\&    # Validate parameters ("pass_again" depends on "pass")
\&    $validation\->required(\*(Aquser\*(Aq)\->size(1, 20)\->like(qr/^[e\-t]+$/);
\&    $validation\->required(\*(Aqpass_again\*(Aq)\->equal_to(\*(Aqpass\*(Aq)
\&      if $validation\->optional(\*(Aqpass\*(Aq)\->size(7, 500)\->is_valid;
\&
\&    # Render confirmation if validation was successful
\&    $self\->render(\*(Aqthanks\*(Aq) unless $validation\->has_error;
\&  } => \*(Aqindex\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head>
\&      %= stylesheet begin
\&        label.field\-with\-error { color: #dd7e5e }
\&        input.field\-with\-error { background\-color: #fd9e7e }
\&      % end
\&    </head>
\&    <body>
\&      %= form_for index => begin
\&        %= label_for user => \*(AqUsername (required, 1\-20 characters, only e\-t)\*(Aq
\&        <br>
\&        %= text_field \*(Aquser\*(Aq
\&        %= submit_button
\&        <br>
\&        %= label_for pass => \*(AqPassword (optional, 7\-500 characters)\*(Aq
\&        <br>
\&        %= password_field \*(Aqpass\*(Aq
\&        <br>
\&        %= label_for pass_again => \*(AqPassword again (equal to the value above)\*(Aq
\&        <br>
\&        %= password_field \*(Aqpass_again\*(Aq
\&      % end
\&    </body>
\&  </html>
\&
\&  @@ thanks.html.ep
\&  <!DOCTYPE html>
\&  <html><body>Thank you <%= validation\->param(\*(Aquser\*(Aq) %>.</body></html>
.Ve
.PP
Form elements generated with tag helpers from
Mojolicious::Plugin::TagHelpers will automatically remember their previous
values and add the class \f(CW\*(C`field\-with\-error\*(C'\fR for fields that failed validation
to make styling with \s-1CSS\s0 easier.
.PP
.Vb 4
\&  <label class="field\-with\-error" for="user">
\&    Username (required, only characters e\-t)
\&  </label>
\&  <input class="field\-with\-error" type="text" name="user" value="sri" />
.Ve
.PP
For a full list of available checks see also
\&\*(L"\s-1CHECKS\s0\*(R" in Mojolicious::Validator.
.SS "Adding form validation checks"
.IX Subsection "Adding form validation checks"
Validation checks can be registered with \*(L"add_check\*(R" in Mojolicious::Validator
and return a false value if they were successful. A true value may be used to
pass along additional information which can then be retrieved with
\&\*(L"error\*(R" in Mojolicious::Validator::Validation.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Add "range" check
\&  app\->validator\->add_check(range => sub {
\&    my ($validation, $name, $value, $min, $max) = @_;
\&    return $value < $min || $value > $max;
\&  });
\&
\&  get \*(Aq/\*(Aq => \*(Aqform\*(Aq;
\&
\&  post \*(Aq/test\*(Aq => sub {
\&    my $self = shift;
\&
\&    # Validate parameters with custom check
\&    my $validation = $self\->validation;
\&    $validation\->required(\*(Aqnumber\*(Aq)\->range(3, 23);
\&
\&    # Render form again if validation failed
\&    return $self\->render(\*(Aqform\*(Aq) if $validation\->has_error;
\&
\&    # Prevent double submit with redirect
\&    $self\->flash(number => $validation\->param(\*(Aqnumber\*(Aq));
\&    $self\->redirect_to(\*(Aqform\*(Aq);
\&  };
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ form.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <body>
\&      % if (my $number = flash \*(Aqnumber\*(Aq) {
\&        <p>Thanks, the number <%= $number %> was valid.</p>
\&      % }
\&      %= form_for test => begin
\&        % if (my $err = validation\->error(\*(Aqnumber\*(Aq)) {
\&          <p>
\&            %= \*(AqValue is required.\*(Aq if $err\->[0] eq \*(Aqrequired\*(Aq
\&            %= \*(AqValue needs to be between 3 and 23.\*(Aq if $err\->[0] eq \*(Aqrange\*(Aq
\&          </p>
\&        % }
\&        %= text_field \*(Aqnumber\*(Aq
\&        %= submit_button
\&      % end
\&    </body>
\&  </html>
.Ve
.SS "Cross-site request forgery"
.IX Subsection "Cross-site request forgery"
\&\s-1CSRF\s0 is a very common attack on web applications that trick your logged in
users to submit forms they did not intend to send. All you have to do to
protect your users from this, is to add an additional hidden field to your
forms with \*(L"csrf_field\*(R" in Mojolicious::Plugin::TagHelpers and validate it
with \*(L"csrf_protect\*(R" in Mojolicious::Validator::Validation.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  get \*(Aq/\*(Aq => {template => \*(Aqtarget\*(Aq};
\&
\&  post \*(Aq/\*(Aq => sub {
\&    my $self = shift;
\&
\&    # Check CSRF token
\&    my $validation = $self\->validation;
\&    return $self\->render(text => \*(AqBad CSRF token!\*(Aq, status => 403)
\&      if $validation\->csrf_protect\->has_error(\*(Aqcsrf_token\*(Aq);
\&
\&    my $city = $validation\->required(\*(Aqcity\*(Aq)\->param(\*(Aqcity\*(Aq);
\&    $self\->render(text => "Low orbit ion cannon pointed at $city!")
\&      unless $validation\->has_error;
\&  } => \*(Aqtarget\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ target.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <body>
\&      %= form_for target => begin
\&        %= csrf_field
\&        %= label_for city => \*(AqWhich city to point low orbit ion cannon at?\*(Aq
\&        %= text_field \*(Aqcity\*(Aq
\&        %= submit_button
\&      %= end
\&    </body>
\&  </html>
.Ve
.PP
The token can also be submitted with the \f(CW\*(C`X\-CSRF\-Token\*(C'\fR request header.
.SS "Adding helpers"
.IX Subsection "Adding helpers"
Adding and redefining helpers is very easy, you can use them to do pretty much
everything.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  helper debug => sub {
\&    my ($self, $str) = @_;
\&    $self\->app\->log\->debug($str);
\&  };
\&
\&  get \*(Aq/\*(Aq => sub {
\&    my $self = shift;
\&    $self\->debug(\*(AqHello from an action!\*(Aq);
\&  } => \*(Aqindex\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.ep
\&  % debug \*(AqHello from a template!\*(Aq;
.Ve
.PP
Helpers can also accept template blocks as last argument, this for example
allows very pleasant to use tag helpers and filters.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Mojo::ByteStream;
\&
\&  helper trim_newline => sub {
\&    my ($self, $block) = @_;
\&    my $result = $block\->();
\&    $result =~ s/\en//g;
\&    return Mojo::ByteStream\->new($result);
\&  };
\&
\&  get \*(Aq/\*(Aq => \*(Aqindex\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.ep
\&  %= trim_newline begin
\&    Some text.
\&    %= 1 + 1
\&    More text.
\&  % end
.Ve
.PP
Wrapping the helper result into a Mojo::ByteStream object can prevent
accidental double escaping.
.SS "Helper plugins"
.IX Subsection "Helper plugins"
Some helpers might be useful enough for you to share them between multiple
applications, plugins make that very simple.
.PP
.Vb 2
\&  package Mojolicious::Plugin::DebugHelper;
\&  use Mojo::Base \*(AqMojolicious::Plugin\*(Aq;
\&
\&  sub register {
\&    my ($self, $app) = @_;
\&    $app\->helper(debug => sub {
\&      my ($self, $str) = @_;
\&      $self\->app\->log\->debug($str);
\&    });
\&  }
\&
\&  1;
.Ve
.PP
The \f(CW\*(C`register\*(C'\fR method will be called when you load the plugin and to add your
helper to the application you can use \*(L"helper\*(R" in Mojolicious.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  plugin \*(AqDebugHelper\*(Aq;
\&
\&  get \*(Aq/\*(Aq => sub {
\&    my $self = shift;
\&    $self\->debug(\*(AqIt works.\*(Aq);
\&    $self\->render(text => \*(AqHello.\*(Aq);
\&  };
\&
\&  app\->start;
.Ve
.PP
A skeleton for a full \s-1CPAN\s0 compatible plugin distribution can be automatically
generated.
.PP
.Vb 1
\&  $ mojo generate plugin DebugHelper
.Ve
.PP
And if you have a \f(CW\*(C`PAUSE\*(C'\fR account (which can be requested at
<http://pause.perl.org>), you are only a few commands away from releasing it
to \s-1CPAN\s0.
.PP
.Vb 5
\&  $ perl Makefile.PL
\&  $ make test
\&  $ make manifest
\&  $ make dist
\&  $ mojo cpanify \-u USER \-p PASS Mojolicious\-Plugin\-DebugHelper\-0.01.tar.gz
.Ve
.SS "Bundling assets with plugins"
.IX Subsection "Bundling assets with plugins"
Assets such as templates and static files can be easily bundled with your
plugins, even if you plan to release them to \s-1CPAN\s0.
.PP
.Vb 7
\&  $ mojo generate plugin AlertAssets
\&  $ mkdir AlertAssets/lib/Mojolicious/Plugin/AlertAssets
\&  $ cd AlertAssets/lib/Mojolicious/Plugin/AlertAssets
\&  $ mkdir public
\&  $ echo \*(Aqalert("Hello World!");\*(Aq > public/alertassets.js
\&  $ mkdir templates
\&  $ echo \*(Aq%= javascript "/alertassets.js"\*(Aq > templates/alertassets.html.ep
.Ve
.PP
Just append their respective directories to the list of search paths when
\&\f(CW\*(C`register\*(C'\fR is called.
.PP
.Vb 2
\&  package Mojolicious::Plugin::AlertAssets;
\&  use Mojo::Base \*(AqMojolicious::Plugin\*(Aq;
\&
\&  use File::Basename \*(Aqdirname\*(Aq;
\&  use File::Spec::Functions \*(Aqcatdir\*(Aq;
\&
\&  sub register {
\&    my ($self, $app) = @_;
\&
\&    # Append "templates" and "public" directories
\&    my $base = catdir(dirname(_\|_FILE_\|_), \*(AqAlertAssets\*(Aq);
\&    push @{$app\->renderer\->paths}, catdir($base, \*(Aqtemplates\*(Aq);
\&    push @{$app\->static\->paths},   catdir($base, \*(Aqpublic\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
Both will work just like normal \f(CW\*(C`templates\*(C'\fR and \f(CW\*(C`public\*(C'\fR directories once
you've installed and loaded the plugin, with slightly lower precedence.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  plugin \*(AqAlertAssets\*(Aq;
\&
\&  get \*(Aq/alert_me\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ alert_me.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head>
\&      <title>Alert me!</title>
\&      %= include \*(Aqalertassets\*(Aq
\&    </head>
\&    <body>You\*(Aqve been alerted.</body>
\&  </html>
.Ve
.PP
And it works just the same for assets bundled in the \f(CW\*(C`DATA\*(C'\fR section of your
plugin.
.PP
.Vb 2
\&  package Mojolicious::Plugin::AlertAssets;
\&  use Mojo::Base \*(AqMojolicious::Plugin\*(Aq;
\&
\&  sub register {
\&    my ($self, $app) = @_;
\&
\&    # Append class
\&    push @{$app\->renderer\->classes}, _\|_PACKAGE_\|_;
\&    push @{$app\->static\->classes},   _\|_PACKAGE_\|_;
\&  }
\&
\&  1;
\&  _\|_DATA_\|_
\&
\&  @@ alertassets.js
\&  alert("Hello World!");
\&
\&  @@ alertassets.html.ep
\&  %= javascript "/alertassets.js"
.Ve
.SH "ADVANCED"
.IX Header "ADVANCED"
Less commonly used and more powerful features.
.SS "Rendering static files"
.IX Subsection "Rendering static files"
If automatic rendering of static files is not enough, you can also render them
manually from your \f(CW\*(C`DATA\*(C'\fR sections and \f(CW\*(C`public\*(C'\fR directories with
\&\*(L"render_static\*(R" in Mojolicious::Controller.
.PP
.Vb 2
\&  $self\->res\->headers\->content_disposition(\*(Aqattachment; filename=bar.png;\*(Aq);
\&  $self\->render_static(\*(Aqfoo/bar.png\*(Aq);
.Ve
.SS "Custom responses"
.IX Subsection "Custom responses"
For entirely custom responses to, for example, stream content directly from
files, you can use \*(L"rendered\*(R" in Mojolicious::Controller to tell the renderer
that a response has been generated.
.PP
.Vb 3
\&  $self\->res\->headers\->content_type(\*(Aqtext/plain\*(Aq);
\&  $self\->res\->content\->asset(Mojo::Asset::File\->new(path => \*(Aq/etc/passwd\*(Aq));
\&  $self\->rendered(200);
.Ve
.SS "Post-processing dynamic content"
.IX Subsection "Post-processing dynamic content"
While post-processing tasks are generally very easy with the hook
\&\*(L"after_dispatch\*(R" in Mojolicious, for content generated by the renderer it is a
lot more efficient to use \*(L"after_render\*(R" in Mojolicious.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use IO::Compress::Gzip \*(Aqgzip\*(Aq;
\&
\&  hook after_render => sub {
\&    my ($c, $output, $format) = @_;
\&
\&    # Check if "gzip => 1" has been set in the stash
\&    return unless $c\->stash\->{gzip};
\&
\&    # Check if user agent accepts GZip compression
\&    return unless ($c\->req\->headers\->accept_encoding // \*(Aq\*(Aq) =~ /gzip/i;
\&    $c\->res\->headers\->append(Vary => \*(AqAccept\-Encoding\*(Aq);
\&
\&    # Compress content with GZip
\&    $c\->res\->headers\->content_encoding(\*(Aqgzip\*(Aq);
\&    gzip $output, \emy $compressed;
\&    $$output = $compressed;
\&  };
\&
\&  get \*(Aq/\*(Aq => {template => \*(Aqhello\*(Aq, title => \*(AqHello\*(Aq, gzip => 1};
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ hello.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title><%= title %></title></head>
\&    <body>Compressed content.</body>
\&  </html>
.Ve
.SS "Chunked transfer encoding"
.IX Subsection "Chunked transfer encoding"
For very dynamic content you might not know the response content length in
advance, that's where the \f(CW\*(C`chunked\*(C'\fR transfer encoding and
\&\*(L"write_chunk\*(R" in Mojolicious::Controller come in handy. A common use would be
to send the \f(CW\*(C`head\*(C'\fR section of an \s-1HTML\s0 document to the browser in advance and
speed up preloading of referenced images and stylesheets.
.PP
.Vb 4
\&  $self\->write_chunk(\*(Aq<html><head><title>Example</title></head>\*(Aq => sub {
\&    my $self = shift;
\&    $self\->finish(\*(Aq<body>Example</body></html>\*(Aq);
\&  });
.Ve
.PP
The optional drain callback ensures that all previous chunks have been
written before processing continues. An empty chunk or call to
\&\*(L"finish\*(R" in Mojolicious::Controller marks the end of the stream.
.PP
.Vb 5
\&  29
\&  <html><head><title>Example</title></head>
\&  1b
\&  <body>Example</body></html>
\&  0
.Ve
.PP
Especially in combination with long inactivity timeouts this can be very
useful for Comet (long polling). Due to limitations in some web servers this
might not work perfectly in all deployment environments.
.SS "Encoding"
.IX Subsection "Encoding"
Templates stored in files are expected to be \f(CW\*(C`UTF\-8\*(C'\fR by default, but that can
be easily changed with \*(L"encoding\*(R" in Mojolicious::Renderer.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Different encoding
\&    $self\->renderer\->encoding(\*(Aqkoi8\-r\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
All templates from the \f(CW\*(C`DATA\*(C'\fR section are bound to the encoding of the Perl
script.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  get \*(Aq/heart\*(Aq;
\&
\&  app\->start;
\&
\&  _\|_DATA_\|_
\&  @@ heart.html.ep
\&  I X Mojolicious!
.Ve
.SS "Base64 encoded \s-1DATA\s0 files"
.IX Subsection "Base64 encoded DATA files"
Base64 encoded static files such as images can be easily stored in the \f(CW\*(C`DATA\*(C'\fR
section of your application, similar to templates.
.PP
.Vb 2
\&  @@ favicon.ico (base64)
\&  ...base64 encoded image...
.Ve
.SS "Inflating \s-1DATA\s0 templates"
.IX Subsection "Inflating DATA templates"
Templates stored in files get preferred over files from the \f(CW\*(C`DATA\*(C'\fR section,
this allows you to include a default set of templates in your application that
the user can later customize. The command Mojolicious::Command::inflate
will write all templates and static files from the \f(CW\*(C`DATA\*(C'\fR section into actual
files in the \f(CW\*(C`templates\*(C'\fR and \f(CW\*(C`public\*(C'\fR directories.
.PP
.Vb 1
\&  $ ./myapp.pl inflate
.Ve
.SS "Customizing the template syntax"
.IX Subsection "Customizing the template syntax"
You can easily change the whole template syntax by loading
Mojolicious::Plugin::EPRenderer with a custom configuration.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  plugin EPRenderer => {
\&    name     => \*(Aqmustache\*(Aq,
\&    template => {
\&      tag_start => \*(Aq{{\*(Aq,
\&      tag_end   => \*(Aq}}\*(Aq
\&    }
\&  };
\&
\&  get \*(Aq/:name\*(Aq => {name => \*(AqAnonymous\*(Aq} => \*(Aqindex\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.mustache
\&  Hello {{= $name }}.
.Ve
.PP
Mojo::Template contains the whole list of available options.
.SS "Adding your favorite template system"
.IX Subsection "Adding your favorite template system"
Maybe you would prefer a different template system than \f(CW\*(C`ep\*(C'\fR, and there is
not already a plugin on \s-1CPAN\s0 for your favorite one, all you have to do is add
a new \f(CW\*(C`handler\*(C'\fR with \*(L"add_handler\*(R" in Mojolicious::Renderer when \f(CW\*(C`register\*(C'\fR
is called.
.PP
.Vb 2
\&  package Mojolicious::Plugin::MyRenderer;
\&  use Mojo::Base \*(AqMojolicious::Plugin\*(Aq;
\&
\&  sub register {
\&    my ($self, $app) = @_;
\&
\&    # Add "mine" handler
\&    $app\->renderer\->add_handler(mine => sub {
\&      my ($renderer, $c, $output, $options) = @_;
\&
\&      # Check for one\-time use inline template
\&      my $inline = $options\->{inline};
\&
\&      # Check for absolute template path
\&      my $path = $renderer\->template_path($options);
\&
\&      # Check for appropriate template in DATA section
\&      my $data = $renderer\->get_data_template($options);
\&
\&      # This part is up to you and your template system :)
\&      ...
\&
\&      # Just die if an error occurs
\&      die \*(AqSomething went wrong\*(Aq;
\&
\&      # Or pass the rendered result back to the renderer
\&      $$output = \*(AqHello World!\*(Aq;
\&
\&      # And return true if something has been rendered or false otherwise
\&      return 1;
\&    });
\&  }
\&
\&  1;
.Ve
.PP
Since most template systems don't support templates in the \f(CW\*(C`DATA\*(C'\fR section,
the renderer provides methods to help you with that.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  plugin \*(AqMyRenderer\*(Aq;
\&
\&  get \*(Aq/\*(Aq => \*(Aqindex\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.mine
\&  ...
.Ve
.SS "Adding a handler to generate binary data"
.IX Subsection "Adding a handler to generate binary data"
By default the renderer assumes that every \f(CW\*(C`handler\*(C'\fR generates characters
that need to be automatically encoded, but this can be easily disabled if
you're generating bytes instead.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Mango::BSON \*(Aq:bson\*(Aq;
\&
\&  # Add "bson" handler
\&  app\->renderer\->add_handler(bson => sub {
\&    my ($renderer, $c, $output, $options) = @_;
\&
\&    # Disable automatic encoding
\&    delete $options\->{encoding};
\&
\&    # Encode BSON data from stash value
\&    $$output = bson_encode delete $c\->stash\->{bson};
\&
\&    return 1;
\&  });
\&
\&  get \*(Aq/\*(Aq => {bson => {i => \*(AqX mojolicious\*(Aq}, handler => \*(Aqbson\*(Aq};
\&
\&  app\->start;
.Ve
.SH "MORE"
.IX Header "MORE"
You can continue with Mojolicious::Guides now or take a look at the
<Mojolicious wiki>, which contains a lot
more documentation and examples by many different authors.
.SH "SUPPORT"
.IX Header "SUPPORT"
If you have any questions the documentation might not yet answer, don't
hesitate to ask on the
<mailing-list> or the official \s-1IRC\s0
channel \f(CW\*(C`#mojo\*(C'\fR on \f(CW\*(C`irc.perl.org\*(C'\fR.
